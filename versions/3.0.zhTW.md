# OpenAPI Specification

#### Version 3.0.0-rc0

本文件之關鍵字，必須"MUST"、必須不/不必"MUST NOT"、必要"REQUIRED"、應該"SHALL"、應該不/不應"SHALL NOT"、應該"SHOULD"、應該不/不應"SHOULD NOT"、建議"RECOMMENDED"、可以"MAY"、可選擇的"OPTIONAL"的意義是根據[RFC 2119](http://www.ietf.org/rfc/rfc2119.txt)描述內容所示。
本文件根據[The Apache License, Version 2.0](http://www.apache.org/licenses/LICENSE-2.0.html)進行授權。

## 導論
Open API規格(OAS)是用於描述與紀錄RESTful API的專案。


Open API規範定義描述一支API所需之文件。
這些文件隨後可以被文件產生工具利用來呈現API與編碼產生工具用以在多種程式語言中產生客戶端。

額外的公用程式亦能從成果文件中獲得好處，例如測試工具。

## 目錄
<!-- TOC depthFrom:1 depthTo:3 withLinks:1 updateOnSave:1 orderedList:0 -->

- [定義](#definitions)
	- [路徑模板](#pathTemplating)
	- [媒體類型](#mediaTypes)
	- [HTTP狀態碼](#httpCodes)
- [規格](#Specification)
	- [格式](#format)
	- [文件結構](#fileStructure)
	- [資料類型](#dataTypes)
	- [URL相關參考](#relativeReferences)
	- [綱要](#schema)
		- [OpenAPI 物件](#oasObject)
		- [資訊物件](#infoObject)
		- [聯絡物件](#contactObject)
		- [授權物件](#licenseObject)
		- [伺服器物件](#serverObject)
        - [伺服器變數物件](#serverVariablesObject)
        - [伺服器變數物件](#serverVariableObject)
		- [元件物件](#componentsObject)
		- [路徑物件](#pathsObject)
		- [路徑項目物件](#pathItemObject)
		- [運算物件](#operationObject)
		- [外部文件物件](#externalDocumentationObject)
		- [參數物件](#parameterObject)
		- [Request Body Object](#requestBodyObject)
		- [內容物件](#contentObject)
		- [媒體類型物件](#mediaTypeObject)
		- [回應物件](#responsesObject)
		- [回應物件](#responseObject)
		- [標頭物件](#headersObject)
		- [範例物件](#exampleObject)
		- [連結物件](#linksObject)
		- [連結物件](#linkObject)
		- [連結參數物件](#linkParametersObject)
		- [標頭物件](#headerObject)
		- [標籤物件](#tagObject)
		- [範例物件](#examplesObject)
		- [參考物件](#referenceObject)
		- [綱要物件](#schemaObject)
		- [XML物件](#xmlObject)
		- [安全綱要物件](#securitySchemeObject)
		- [範圍物件](#scopesObject)
		- [安全需求物件](#securityRequirementObject)
	- [規格擴充](#specificationExtensions)
	- [安全篩選](#securityFiltering)
- [附錄 A: 修訂歷史](#revisionHistory)
	

<!-- /TOC -->

## 定義 Definitions

##### <a name="pathTemplating"></a>路徑模板
路徑模板係指利用大括弧({})來標計一組URL區域作為使用路徑參數的替代物。

##### <a name="mediaTypes"></a>媒體類型
媒體類型定義分散於多種資源中的。
媒體類型定義應該符合[RFC 6838](http://tools.ietf.org/html/rfc6838).

以下是可能為媒體類型定義的範例:
```
  text/plain; charset=utf-8
  application/json
  application/vnd.github+json
  application/vnd.github.v3+json
  application/vnd.github.v3.raw+json
  application/vnd.github.v3.text+json
  application/vnd.github.v3.html+json
  application/vnd.github.v3.full+json
  application/vnd.github.v3.diff
  application/vnd.github.v3.patch
```
##### <a name="httpCodes"></a>HTTP狀態碼
HTTP狀態碼用於指涉被執行運算之狀態。 
可使用的狀態碼由[RFC 7231](http://tools.ietf.org/html/rfc7231#section-6)所定義並且已註冊狀態碼被列於[IANA Status Code Registry](http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml).

## 規格 Specification

### 格式

與本規範一致的RESTful API描述文件以JSON物件方式呈現並且遵照JSON標準。
YAML，作為一組JSON超集合的格式，亦可以用來呈現一份OAS文件。 

例如，如果一組欄位有一組陣列值，則JSON陣列呈現將被使用:

```json
{
   "field": [...]
}
```

當API使用JSON來描述，便不會在該API自身上加諸JSON的輸入與輸出。

所有在本規格中的欄位名稱皆是 **大小寫有別的**.

本綱要揭露兩類型欄位。
有一宣告名稱的固定欄位，以及針對欄位名稱宣告一正則表達式態樣的態樣欄位。
只要每個欄位具有獨特名稱，態樣欄位可以具有多種事件。 

為了保留YAML與JSON格式間往返的能力，建議與某些額外限制搭配使用YAML version [1.2](http://www.yaml.org/spec/1.2/spec.html):

- 標籤必須限制於[JSON Schema ruleset](http://www.yaml.org/spec/1.2/spec.html#id2803231)所允許的範圍內。
- 使用於YAML地圖中的鑰匙必須限制在純量字串，如同[YAML Failsafe schema ruleset](http://yaml.org/spec/1.2/spec.html#id2802346)所定義的。

### <a name="fileStructure"></a>文件結構

API的OAS表示法是由單一文件製成。
然而，部分定義可以在使用者斟酌下分列於不同的文件中。
這點可以適用於規格中的`$ref`欄位，一如遵照[JSON Schema](http://json-schema.org)的定義。
按照慣例，建議將OpenAPI規格(OAS)文件命名為`openapi.json`或`openapi.yaml`。

### <a name="dataTypes"></a>資料類型

在OAS中的資料類型是依據[JSON Schema Specification Wright Draft 00](https://tools.ietf.org/html/draft-wright-json-schema-00#section-4.2)支援的類型而定。 
注意，作為一種類型的`integer`是同樣被支援的並且無需分數或指數皆被定義為一JSON數字。 
`null`不支援作為一組數值。 
模型使用JSON Schema Specification Wright Draft 00的一擴充子集[Schema Object](#schemaObject)來描述。

<a name="dataTypeFormat"></a>基本資料具有一個可選擇修飾詞屬性: `format`。
OAS使用許多已知的格式來更完善定義正被使用的資料類型。
然而，`format`屬性是一開放的字串值屬性(`string`-valued property)，並且可以具有任一支援文件需求的值。
譬如`"email"`、`"uuid"`等格式，即使他們沒有被本規範所定義，亦可被使用。
沒有伴隨一組`format`屬性的類型，則遵照其在JSON綱要(JSON Schema)中的定義。不被承認為一組特定`format`的工具，可以單獨預設回`type`，猶如該`format`不被特別指定一般。
根據OAS定義的格式為:


通用名稱 | [`類型`](#dataTypeType) | [`格式`](#dataTypeFormat) | 註解
----------- | ------ | -------- | --------
integer | `integer` | `int32` | signed 32 bits
long | `integer` | `int64` | signed 64 bits
float | `number` | `float` | |
double | `number` | `double` | |
string | `string` | | |
byte | `string` | `byte` | base64 編碼字元
binary | `string` | `binary` | 任一8位元組序列
boolean | `boolean` | | |
date | `string` | `date` | 由`full-date` - [RFC3339](http://xml2rfc.ietf.org/public/rfc/html/rfc3339.html#anchor14)所定義
dateTime | `string` | `date-time` | 由`date-time` - [RFC3339](http://xml2rfc.ietf.org/public/rfc/html/rfc3339.html#anchor14)所定義
password | `string` | `password` | 用於暗示使用者介面該輸入必須被遮蔽

### <a name="relativeReferences"></a>URL相關參考

除非特定，否則所有是URL的屬性，一如[RFC 3986](https://tools.ietf.org/html/rfc3986#section-4.2)所定義的，可以作為相關參考.
利用於[`Server Object`](#serverObject)中定義的URL作為基礎URI，相關參考是可以被解決的。

在`$ref`中利用的相關參考要如每一筆[JSON Reference](https://tools.ietf.org/html/draft-pbryan-zyp-json-ref-03)來被處理，例如目前文件中正在作為基礎URI使用的URL。同時請參考[Reference Object](#referenceObject)。

### 綱要

在下列描述中，如果某一欄位沒有明確標明**必要**或用必須或應該所描述的，都可以視為可選擇的。 

#### <a name="oasObject"></a>OpenAPI 物件

這是API規格的根文件物件。
一起結合先前資源列表(Resource Listing)與API宣告(API Declaration，1.2與更早版本)至單一文件中。

##### 固定欄位

欄位名稱 | 類型 | 描述
---|:---:|---
<a name="oasVersion"></a>openapi | `string` | **必要**。 指定正在使用之OpenAPI規格版本。可以根據加工規格和客戶端來用於解釋該版本。結構應該為`major`、`minor`、`patch`，其中`patch`版本必須與現有`major`、`minor`模具相容。典型修補程式版本要導入來處理文件中的錯誤，以及模具通常應該與相應`major`和`minor`相容(3.0.*)。修補程式版本將對應本文件之修正。
<a name="oasInfo"></a>info | [Info Object](#infoObject) | **必要**。 提供有關API之詮釋資料。如果需要，詮釋資料可以為客戶端所使用。
<a name="oasServers"></a>servers | [[Server Object](#serverObject)] | 一組伺服器物件的可選擇陣列，提供連接資訊給予目標伺服器。
<a name="oasPaths"></a>paths | [Paths Object](#pathsObject) | **必要**。該API的可利用路徑與運算。
<a name="oasComponents"></a>components | [Components Object](#componentsObject) | 針對規格保有多種綱要的元素物件。
<a name="oasSecurity"></a>security | [[Security Requirement Object](#securityRequirementObject)] | 可以跨API間使用之安全機制的宣告。數值名單包含可被利用的替代性安全需求。 僅一項安全需求物件需要被滿足來授權一項要求。個別運算可以覆寫本定義。
<a name="oasTags"></a>tags | [[Tag Object](#tagObject)] | 具額外詮釋資料規格所使用的標籤名單。標籤的順序可以被用於反射他們在剖析工具上的順序。並非所有被[Operation Object](#operationObject)所利用的標籤都必須被宣告。沒有被宣告的標籤可以隨機組織或依據工具邏輯來建置。每個名單中的標籤名必須是獨特的。
<a name="oasExternalDocs"></a>externalDocs | [External Documentation Object](#externalDocumentationObject) | 額外外部文件

本物件可以由[規格擴充](#specificationExtensions)來進行擴充。 

#### <a name="oasVersionString"></a>OpenAPI版本字串

版本字串表示文件執行的OpenAPI規格版本。本字串的格式必須是`major`、`minor`、`patch`。`patch`可以由連字符號和額外字母字元來後綴。

`major`、`minor`應該被用於指定OpenAPI規格版本，並且將被視為與那些`major`、`minor`版本指定的OpenAPI規格版本相容。修補程式版本將不被模具所考慮，`3.0.0`與`3.0.1`間沒有差別。

在隨後的OpenAPI規格版本中，會注意`minor`版本的增量不應該干擾在較低次要版本中模具發展的運算。因此，假定的`3.1.0`規格應該可讓針對`3.0.0`設計的模具方便使用.


#### <a name="infoObject"></a>資訊物件

本物件提供有關API的詮釋資料。
如果需要，詮釋資料可以為客戶端所使用，並且為了便利，可以顯示於編輯與文件產生工具中。

##### 固定欄位

欄位名稱 | 類型 | 描述
---|:---:|---
<a name="infoTitle"></a>title | `string` | **必要**。 應用標題。
<a name="infoDescription"></a>description | `string` | 應用的簡短描述。富文字呈現可以使用[CommonMark syntax](http://spec.commonmark.org/)。
<a name="infoTermsOfService"></a>termsOfService | `string` | API服務條款的URL。
<a name="infoContact"></a>contact | [Contact Object](#contactObject) | 被揭露API的聯絡資訊。
<a name="infoLicense"></a>license | [License Object](#licenseObject) | 被揭露API的授權資訊。
<a name="infoVersion"></a>version | `string` | **必要**。 API定義的版本(與OpenAPI規格版本或API執行版本有所區別)。

本物件可以由[規格擴充](#specificationExtensions)來進行擴充。 

##### 資訊物件範例:

```json
{
  "title": "Sample Pet Store App",
  "description": "This is a sample server for a pet store.",
  "termsOfService": "http://example.com/terms/",
  "contact": {
    "name": "API Support",
    "url": "http://www.example.com/support",
    "email": "support@example.com"
  },
  "license": {
    "name": "Apache 2.0",
    "url": "http://www.apache.org/licenses/LICENSE-2.0.html"
  },
  "version": "1.0.1"
}
```

```yaml
title: Sample Pet Store App
description: This is a sample server for a pet store.
termsOfService: http://example.com/terms/
contact:
  name: API Support
  url: http://www.example.com/support
  email: support@example.com
license:
  name: Apache 2.0
  url: http://www.apache.org/licenses/LICENSE-2.0.html
version: 1.0.1
```

#### <a name="contactObject"></a>聯絡物件

被揭露API的聯絡資訊。

##### 固定欄位

欄位名稱 | 類型 | 描述
---|:---:|---
<a name="contactName"></a>name | `string` | 聯絡人/組織的確定名稱。
<a name="contactUrl"></a>url | `string` | 指向聯絡資訊的URL。必須是URL格式。
<a name="contactEmail"></a>email | `string` | 聯絡人/組織的電子郵件地址。必須是電子郵件地址格式。

本物件可以由[規格擴充](#specificationExtensions)來進行擴充。 

##### 聯絡物件範例:

```json
{
  "name": "API Support",
  "url": "http://www.example.com/support",
  "email": "support@example.com"
}
```

```yaml
name: API Support
url: http://www.example.com/support
email: support@example.com
```

#### <a name="licenseObject"></a>授權物件

被揭露API的授權資訊。

##### 固定欄位

欄位名稱 | 類型 | 描述
---|:---:|---
<a name="licenseName"></a>name | `string` | **必要**。 API使用之授權名稱。
<a name="licenseUrl"></a>url | `string` | 指向用於API授權之URL。必須是URL格式。

本物件可以由[規格擴充](#specificationExtensions)來進行擴充。 

##### 授權物件範例:

```json
{
  "name": "Apache 2.0",
  "url": "http://www.apache.org/licenses/LICENSE-2.0.html"
}
```

```yaml
name: Apache 2.0
url: http://www.apache.org/licenses/LICENSE-2.0.html
```

#### <a name="serverObject"></a>伺服器物件

代表一個伺服器的物件。

##### 固定欄位

欄位名稱 | 類型 | 描述
---|:---:|---
<a name="serverUrl"></a>url | `string` | 指向目標主機之URL。該URL支援伺服器變數(Server Variables)並且可以是相對的，來指涉主機位置與服務OpenAPI定義之相對位置。當變數在`{`括號`}`中被命名，則變數替代物將被製出。
<a name="serverDescription"></a>description | `string` | 一組描述由URL指定主機的可選擇字串。
<a name="serverVariables"></a>variables | [Server Variables Object](#serverVariablesObject) | 保有針對URL模組替代物變數的物件。

本物件可以由[規格擴充](#specificationExtensions)來進行擴充。 

##### 伺服器物件範例

單一伺服器將被描述為:

```yaml
url: https://development.gigantic-server.com/v1
description: Development server
```

下列顯示多重伺服器如何被描述，例如在OpenAPI物件的`servers`(#oasServers):

```yaml
servers:
- url: https://development.gigantic-server.com/v1
  description: Development server
- url: https://staging.gigantic-server.com/v1
  description: Staging server
- url: https://api.gigantic-server.com/v1
  description: Production server
```

下列顯示變數如何針對伺服器組態使用變數:

```yaml
servers:
- url: https://{username}.gigantic-server.com:{port}/{basePath}
  description: The production API server
  variables:
    username:
      # note! no enum here means it is an open value
      default: demo
      description: this value is assigned by the service provider, in this example `gigantic-server.com`
    port:
      enum:
        - 8443
        - 443
      default: 8443
    basePath:
      # open meaning there is the opportunity to use special base paths as assigned by the provider, default is `v2`
      default: v2
```

#### <a name="serverVariablesObject"></a>伺服器變數物件

##### 樣態欄位

欄位樣態 | 類型 | 描述
---|:---:|---
<a name="serverVariablesName"></a> {name} | [Server Variable Object](#serverVariableObject) | 在一伺服器URL模組中用於表示替代物的變數。

本物件可以由[規格擴充](#specificationExtensions)來進行擴充。 


#### <a name="serverVariableObject"></a>伺服器變數物件

代表伺服器URL模組替代物的伺服器變數的物件。

欄位名稱 | 類型 | 描述
---|:---:|---
<a name="serverVariableEnum"></a>enum | [`primitive`] | 如果替代物選項來自一組限制的設定，則會使用基本類型值的列舉。
<a name="serverVariableDefault"></a>default | `primitive` |  **必要**。 如果備用值沒有被指定，則使用預設值為代替，並且如果沒有供給備用值則會被發送。與[綱要物件](#schemaObject)的`default`不同，這個值必須由消費者提供。
<a name="serverVariableDescription"></a>description | `string` | 一項針對伺服器變數的可選擇性描述。

本物件可以由[規格擴充](#specificationExtensions)來進行擴充。 

#### <a name="componentsObject"></a>元件物件
保有針對OAS不同面向的一組可復用物件。
所有在元件物件定義中的物件，除非他們明顯地將被元件物件外的屬性所引用，否則不對API起作用。


##### 固定欄位
欄位名稱 | 類型 | 描述
---|:---|---
<a name="componentsSchemas"></a> schemas | Map[`string`, [Schema Object](#schemaObject)] | 保有可復用[綱要物件](#schemaObject)的物件。
<a name="componentsResponses"></a> responses | Map[`string`, [Response Object](#responseObject)] | 保有可復用[回應物件](#responseObject)的物件。
<a name="componentsParameters"></a> parameters | Map[`string`, [Parameter Object](#parameterObject)] | 保有可復用[參數物件](#parameterObject)的物件。
<a name="componentsExamples"></a> examples | Map[`string`, [Example Object](#exampleObject)] | 保有可復用 [範例物件](#exampleObject)的物件。
<a name="componentsRequestBodies"></a> requestBodies | Map[`string`, [Request Body Object](#requestBodyObject)] | 保有可復用[Request Body Objects](#requestBodyObject)的物件。
<a name="componentsHeaders"></a> headers | Map[`string`, [Header object](#headerObject)] | 保有可復用[標頭物件](#headerObject)的物件。
<a name="componentsSecuritySchemes"></a> securitySchemes| Map[`string`, [Security Scheme Object](#securitySchemeObject)] | 保有可復用[安全綱要物件](#securitySchemeObject)的物件。
<a name="componentsLinks"></a> links | Map[`string`, [Link Object](#linkObject)] | 保有可復用[連結物件](#linkObject)的物件。
<a name="componentsCallbacks"></a> callbacks | Map[`string`, [Callback Object](#callbackObject)] | 保有可復用[回呼物件](#callbackObject)的物件。
本物件可以由[規格擴充](#specificationExtensions)來進行擴充。 

所有上述宣告的固定欄位皆是必須使用符合正則表達式鑰匙的物件: `[a-zA-Z0-9.\-_]+`。

固定欄位範例:

```
User
User_1
User_Name
user-name
my.org.User
my\org\User
```

##### 元件物件範例
```json
"components": {
  "schemas": {
      "Category": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64"
          },
          "name": {
            "type": "string"
          }
        }
      },
      "Tag": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64"
          },
          "name": {
            "type": "string"
          }
        }
      }
    }
  },
  "parameters": {
    "skipParam": {
      "name": "skip",
      "in": "query",
      "description": "number of items to skip",
      "required": true,
      "schema": {
        "type": "integer",
        "format": "int32"
      }
    },
    "limitParam": {
      "name": "limit",
      "in": "query",
      "description": "max records to return",
      "required": true,
      "schema" : {
        "type": "integer",
        "format": "int32"
      }
    }
  },
  "responses": {
    "NotFound": {
      "description": "Entity not found."
    },
    "IllegalInput": {
      "description": "Illegal input for operation."
    },
    "GeneralError": {
      "description": "General Error",
      "content": {
        "application/json": {
          "schema": {
            "$ref": "#/components/schemas/GeneralError"
          }
        }
      }
    }
  },
  "securitySchemes": {
    "api_key": {
      "type": "apiKey",
      "name": "api_key",
      "in": "header"
    },
    "petstore_auth": {
      "type": "oauth2",
      "flow": {
        "implicit": {
          "authorizationUrl": "http://example.org/api/oauth/dialog",
          "scopes": {
            "write:pets": "modify pets in your account",
            "read:pets": "read your pets"
          }
        }
      }
    }
  }
}
```

```yaml
components:
  schemas:
    Category:
      type: object
      properties:
        id:
          type: integer
          format: int64
        name:
          type: string
    Tag:
      type: object
      properties:
        id:
          type: integer
          format: int64
        name:
          type: string
  parameters:
    skipParam:
      name: skip
      in: query
      description: number of items to skip
      required: true
      schema:
        type: integer
        format: int32
    limitParam:
      name: limit
      in: query
      description: max records to return
      required: true
      schema:
        type: integer
        format: int32
  responses:
    NotFound:
      description: Entity not found.
    IllegalInput:
      description: Illegal input for operation.
    GeneralError:
      description: General Error
      content:
        application/json
          schema:
            $ref: '#/components/schemas/GeneralError'
  securitySchemas:
    api_key:
      type: apiKey
      name: api_key
      in: header
    petstore_auth:
      type: oauth2
      flow: 
        implicit:
          authorizationUrl: http://example.org/api/oauth/dialog
          scopes:
            write:pets: modify pets in your account
            read:pets: read your pets
```


#### <a name="pathsObject"></a>路徑物件

保有個別端點及其運算的相對路徑。
這項路徑是被添加至來自[`伺服器物件`](#serverObject)的URL中，以建構完整的URL。由於[ACL constraints](#securityFiltering)，這項路徑可以是空的。

##### 樣態欄位
欄位樣態 | 類型 | 描述
---|:---:|---
<a name="pathsPath"></a>/{path} | [Path Item Object](#pathItemObject) | 指向個別端點的相對路徑。該欄位名稱必須以斜線(slash)為開頭。為了建構完整URL，該路徑是被**添加**至來自[`伺服器物件`](#serverObject)之`url`欄位中之URL之中(非相對URL解決方案)。[路徑模板](#pathTemplating)是被允許的。

本物件可以由[規格擴充](#specificationExtensions)來進行擴充。

##### 路徑物件範例

```json
{
  "/pets": {
    "get": {
      "description": "Returns all pets from the system that the user has access to",
      "responses": {
        "200": {          
          "description": "A list of pets.",
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/pet"
                }
              }
            }
          }
        }
      }
    }
  }
}
```

```yaml
/pets:
  get:
    description: Returns all pets from the system that the user has access to
    responses:
      '200':
        description: A list of pets.
        content:
          application/json:
            schema:
              type: array
              items:
                $ref: '#/components/schemas/pet'
```

#### <a name="pathItemObject"></a>路徑項目物件

描述在單一路徑上可用之運算。
由於[ACL constraints](#securityFiltering)，一個路徑項目可以是空的。
該路徑本身仍被揭露至文件閱覽器，但是它們不會得知那些運算與參數是可用的。

##### 固定欄位

Field Name | Type | Description
---|:---:|---
<a name="pathItemRef"></a>$ref | `string` | 允許該路徑項目的外部定義。參考架構必須是一項[路徑項目物件](#pathItemObject)的格式。如果在參考定義與本路徑項目定義間有衝突，則行為是*undefined*。
<a name="pathItemSummary"></a>summary| `string` | 一個可選擇性，字串概要，意欲應用至本路徑之所有運算。
<a name="pathItemDescription"></a>description | `string` | 一個可選擇性，字串概要，意欲應用至本路徑之所有運算。
<a name="pathItemGet"></a>get | [Operation Object](#operationObject) | 在本路徑上一個取得(GET)運算的定義。
<a name="pathItemPut"></a>put | [Operation Object](#operationObject) | 在本路徑上一個放置(PUT)運算的定義。
<a name="pathItemPost"></a>post | [Operation Object](#operationObject) | 在本路徑上一個張貼(POST)運算的定義。
<a name="pathItemDelete"></a>delete | [Operation Object](#operationObject) | 在本路徑上一個刪除(DELET)運算的定義。
<a name="pathItemOptions"></a>options | [Operation Object](#operationObject) | 在本路徑上一個選項(OPTIONS)運算的定義。
<a name="pathItemHead"></a>head | [Operation Object](#operationObject) | 在本路徑上一個首部(HEAD)運算的定義。
<a name="pathItemPatch"></a>patch | [Operation Object](#operationObject) | 在本路徑上一個修補程式(PATCH)運算的定義。
<a name="pathItemTrace"></a>trace | [Operation Object](#operationObject) | 在本路徑上一個追蹤(TRACE)運算的定義。
<a name="pathItemServers"></a>servers | [Server Object](#serverObject) | 一個服務本路徑上所有運算之替代`server`陣列。  
<a name="pathItemParameters"></a>parameters | [[Parameter Object](#parameterObject) <span>&#124;</span> [Reference Object](#referenceObject)] | 一份可以在本路徑下所有被描述運算中可應用的參數名單。這些參數可以在運算層次上被覆寫，但是不能被移除。該名單必須不含重複的參數。一個獨特的參數由[名稱](#parameterName)與[位置](#parameterIn)的結合所定義。該名單可以用[參考物件](#referenceObject)來連結至在[OpenAPI物件參數](#oasParameters)上被定義的參數。 


本物件可以由[規格擴充](#specificationExtensions)來進行擴充。 

##### 路徑項目物件範例

```json
{
  "get": {
    "description": "Returns pets based on ID",
    "summary": "Find pets by ID",
    "operationId": "getPetsById",
    "responses": {
      "200": {
        "description": "pet response",
        "content": {
          "*": {
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/Pet"
              }
            }
          }
        }
      },
      "default": {
        "description": "error payload",
        "content": {
          "text/html": {
            "schema": {
              "$ref": "#/components/schemas/ErrorModel"
            }
          }
        }
      }
    }
  },
  "parameters": [
    {
      "name": "id",
      "in": "path",
      "description": "ID of pet to use",
      "required": true,
      "type": "array",
      "items": {
        "type": "string"
      },
      "style": "commaDelimited"
    }
  ]
}
```

```yaml
get:
  description: Returns pets based on ID
  summary: Find pets by ID
  operationId: getPetsById
  responses:
    '200':
      description: pet response
      content:
        *:
          schema:
            type: array
            items:
              $ref: '#/components/schemas/Pet'
    default:
      description: error payload
      content:
        'text/html':
          schema:
            $ref: '#/components/schemas/ErrorModel'
parameters:
- name: id
  in: path
  description: ID of pet to use
  required: true
  type: array
  format: form
  items:
    type: string  
```

#### <a name="operationObject"></a>運算物件

描述在一路徑上單一API運算。

##### 固定欄位

欄位名稱 | 類型 | 描述
---|:---:|---
<a name="operationTags"></a>tags | [`string`] | 針對API文件控制的標籤名單。標籤可以藉由資源或其他限定符用於運算的邏輯群組。
<a name="operationSummary"></a>summary | `string` | 該運作作何用的簡短概述。為了在編輯或文件產生器中的最大化可讀性，這項欄位內容應該要少於120字元。
<a name="operationDescription"></a>description | `string` | 運算行為的詳細解釋。為了富文字呈現，可以使用[CommonMark syntax](http://spec.commonmark.org/)。
<a name="operationExternalDocs"></a>externalDocs | [External Documentation Object](#externalDocumentationObject) | 本運算的額外外部文件。
<a name="operationId"></a>operationId | `string` | 用於定義運算的獨特字串。在所有該API中被描述運算中，其ID必須是獨特的。工具和函式庫可以使用operationId以獨特地定義一項運算，因此，建議遵照共通性程式命名慣例。
<a name="operationParameters"></a>parameters | [[Parameter Object](#parameterObject) <span>&#124;</span> [Reference Object](#referenceObject)] | 可應用於本運算之參數名單。如果一項參數已經在[路徑項目](#pathItemParameters)上被定義，則新的定義將會覆寫之，但是不能移除之。該名單必須不含重複的參數。一個獨特的參數由[名稱](#parameterName)與[位置](#parameterIn)的結合所定義。該名單可以用[參考物件](#referenceObject)來連結至在[OpenAPI物件參數](#oasParameters)上被定義的參數。
<a name="operationRequestBody"></a>requestBody | [[Request Body Object](#requestBodyObject) <span>&#124;</span> [Reference Object](#referenceObject)] | 可應用於本運算之request body。`requestBody`僅在[HTTP 1.1 specification](https://tools.ietf.org/html/rfc7231#section-4.3.1)已經明確定義request bodies語意的HTTP方法中被支援。在其他當HTTP spec是模糊的例子中，`requestBody`應該被消費者忽略。
<a name="operationResponses"></a>responses | [Responses Object](#responsesObject) | **必要**。 作為他們在執行中運算所被返回的可能回應名單。
<a name="operationCallbacks"></a>callbacks | [Callbacks Object](#callbacksObject) | 作為他們在執行中運算所被返回的可能回呼名單。
<a name="operationDeprecated"></a>deprecated | `boolean` | 宣告本運算已被廢棄。消費者應該避免被宣告運算的利用。預設值是`false`。
<a name="operationSecurity"></a>security | [[Security Requirement Object](#securityRequirementObject)] | 在本運算上可以使用的安全機制宣告。數值名單包含可以被利用的替代安全需求。僅一項安全需求物件需要被滿足來授權一項要求。此定義覆寫任何被宣告的最高層次[`security`](#oasSecurity)。一個空的陣列可以被用於移除一項最高層次安全宣告。
<a name="operationServers"></a>servers | [Server Object](#serverObject) | 一個服務此運算的替代`server`陣列。如果一個替代`server`物件在路徑項目物件或根層次上被指定，則會被此數值所覆寫。

本物件可以由[規格擴充](#specificationExtensions)來進行擴充。 

##### 運算物件範例
```json
{
  "tags": [
    "pet"
  ],
  "summary": "Updates a pet in the store with form data",
  "operationId": "updatePetWithForm",
  "parameters": [
    {
      "name": "petId",
      "in": "path",
      "description": "ID of pet that needs to be updated",
      "required": true,
      "type": "string"
    }
  ],
  "requestBody": {
    "content": {
      "application/x-www-form-urlencoded": {
        "schema": {
          "type": "object",
           "properties": {
              "name": { 
                "description": "Updated name of the pet",
                "type": "string"
              },
              "status": {
                "description": "Updated status of the pet",
                "type": "string"
             }
           },
        "required": ["status"] 
        }
      }
    }
  },
  "responses": {
    "200": {
      "description": "Pet updated.",
      "content": {
        "application/json": {},
        "application/xml": {}
      }
    },
    "405": {
      "description": "Invalid input",
      "content": {
        "application/json": {},
        "application/xml": {}
      }
    }
  },
  "security": [
    {
      "petstore_auth": [
        "write:pets",
        "read:pets"
      ]
    }
  ]
}
```

```yaml
tags:
- pet
summary: Updates a pet in the store with form data
operationId: updatePetWithForm
parameters:
- name: petId
  in: path
  description: ID of pet that needs to be updated
  required: true
  type: string
requestBody:
  content:
    'application/x-www-form-urlencoded':
      schema:
       properties:
          name: 
            description: Updated name of the pet
            type: string
          status:
            description: Updated status of the pet
            type: string
        required: 
          - status
responses:
  '200':
    description: Pet updated.
    content: 
      'application/json': {}
      'application/xml': {}
  '405':
    description: Invalid input
    content: 
      'application/json': {}
      'application/xml': {}
security:
- petstore_auth:
  - write:pets
  - read:pets
```


#### <a name="externalDocumentationObject"></a>外部文件物件

允許引用一項針對擴充文件的外部資源。

##### 固定欄位

欄位名稱 | 類型 | 描述
---|:---:|---
<a name="externalDocDescription"></a>description | `string` | 目標文件的簡短描述。為了富文字呈現，可以使用[CommonMark syntax](http://spec.commonmark.org/)。
<a name="externalDocUrl"></a>url | `string` | **必要**。 針對目標文件的URL。數值必須是一個URL的格式。

本物件可以由[規格擴充](#specificationExtensions)來進行擴充。 

##### 外部文件物件範例

```json
{
  "description": "Find more info here",
  "url": "https://example.com"
}
```

```yaml
description: Find more info here
url: https://example.com
```

#### <a name="parameterObject"></a>參數物件

描述單一運算參數。

一個獨特的參數由[名稱](#parameterName)與[位置](#parameterIn)的結合所定義。.

有四種可能參數位置 (如同`in`欄位所指定的):
* path - 當參數值實際上是運算URL的部分時，與[路徑模板](#pathTemplating)一起使用。 這不包含API的主機或基本路徑。例如，在`/items/{itemId}`之中，路徑參數是`itemId`。
* query - 被添加於URL的參數。例如在`/items?id=###`之中，查詢參數是`id`。
* header - 被預期作為要求部分的定制標頭。注意[RFC 7230](https://tools.ietf.org/html/rfc7230#page-22)聲明，標頭名是大小寫有別的。
* cookie - 被用於傳遞一特定cookie值至API。


##### 固定欄位
欄位名稱 | 類型 | 描述
---|:---:|---
<a name="parameterName"></a>name | `string` | **必要**。 參數的名稱。參數名稱是*大小寫有別的*。 <ul><li>如果[`in`](#parameterIn)是`"path"`，則`name`欄位必須符合[路徑物件](#pathsObject)中[path](#pathsPath)欄位的關聯路徑分段。進一步資訊參見[路徑模板](#pathTemplating)。<li>針對所有其他案例，基於[`in`](#parameterIn)屬性，`name`要符合被使用的參數名稱。</ul>
<a name="parameterIn"></a>in | `string` | **必要**。參數的位置。可能的值是"query"、"header"、"path"或"cookie"。
<a name="parameterDescription"></a>description | `string` | 參數的簡短描述。可以包含使用範例。為了富文字呈現，可以使用[CommonMark syntax](http://spec.commonmark.org/)。
<a name="parameterRequired"></a>required | `boolean` | 決定本參數是否為強制的。如果[parameter location](#parameterIn)是"path"，該屬性是**必要**並且其值必須是`true`。否則，屬性可能被包含並且其值為`false`。 
<a name="parameterDeprecated"></a> deprecated | `boolean` | 指定一項參數是廢棄的，並且應該被轉移至廢棄不用。
<a name="parameterAllowEmptyValue"/>allowEmptyValue | `boolean` | 設定傳遞空值(empty-valued)參數的能力。這是僅針對`query`參數才有效並且允許傳送一組具空值(empty value)的參數。預設值是`false`。如果[`style`](#parameterStyle)被使用，如果行為是`n/a`，則`allowEmptyValue`的值應該被忽略。

針對參數序列化的規則是被指定在兩種方式中的一種。
針對更簡單的場景，一組[`style`](#parameterStyle)與[`schema`](#parameterSchema)可以被用於描述參數的結構與句法。

欄位名稱 | 類型 | 描述
---|:---:|---
<a name="parameterStyle"></a>style | `string` | 描述參數值如何仰賴參數值類型而被序列化。預設值(基於`in`的值): for `query` - `form`; for `path` - `simple`; for `header` - `simple`; for `cookie` - `form`。
<a name="parameterExplode"></a>explode | `boolean` | 當此為真時，`array`或`object`類型參數值針對陣列的每一項值或地圖的鍵對值產生分隔參數。對於參數的其他類型，本屬性沒有作用。當[`style`](#parameterStyle)是`form`時，預設值為`true`。所有其他形式，預設值為`false`。
<a name="parameterAllowReserved"></a>allowReserved | `boolean` | 決定參數值是否應該允許保留字元，如同[RFC3986](https://tools.ietf.org/html/rfc3986#section-2.2)所定義`:/?#[]@!$&'()*+,;=`被包含在內與沒有百分號編碼。這項屬性僅應用於具備一組`query`的`in`值的參數。預設值為`false`。
<a name="parameterSchema"></a>schema | [Schema Object](#schemaObject) <span>&#124;</span> [Reference Object](#referenceObject)] | 定義參數使用類型的綱要。
<a name="parameterExamples"></a>examples | [[Example Object](#exampleObject) <span>&#124;</span> [Reference Object](#referenceObject)] | 內容類型的範例。在範例陣列中的每一個範例應該在正確的格式中，一如指定參數編碼。`examples`物件是與`example`物件相互排斥的。此外，如果引用包含一個範例的`schema`，`examples`值應該_override_ 由該綱要提供的範例。
<a name="parameterExample"></a>example | [Example Object](#exampleObject) <span>&#124;</span> [Reference Object](#referenceObject) | 內容類型的範例。在範例陣列中的每一個範例應該在正確的格式中，一如指定參數編碼。`examples`物件是與`example`物件相互排斥的。此外，如果引用包含一個範例的`schema`，`examples`值應該_override_ 由該綱要提供的範例。

針對更複雜的場景，一項[內容物件](#contentObject)可以被用於定義媒體類型以及參數的綱要。  
此選項與前述之簡單場景互為排斥。 
當`example`或`examples`與`schema`物件連接提供時，該範例必須遵照規定的參數序列化策略。


欄位名稱 | 類型 | 描述
---|:---:|---
<a name="parameterContent"></a>content | [Content Object](#contentObject) | 參數內容。
為了支援序列化簡單參數共通方式，一組`style`值要被定義。

`style` | [`type`](#dataTypeType) |  `in` | Comments
----------- | ------ | -------- | --------
matrix |  `primitive`, `array`, `object` |  `path` | 由[RFC6570](https://tools.ietf.org/html/rfc6570#section-3.2.7)定義之路徑式參數 
label | `primitive`, `array`, `object` |  `path` | 由[RFC6570](https://tools.ietf.org/html/rfc6570#section-3.2.5)定義之標籤式參數
form |  `primitive`, `array`, `object` |  `query`, `cookie` | 由[RFC6570](https://tools.ietf.org/html/rfc6570#section-3.2.8)定義之表單式參數。此選項以一個`csv`值取代`collectionFormat`。 
simple | `array` | `path`, `header` | 由[RFC6570](https://tools.ietf.org/html/rfc6570#section-3.2.2)定義之簡易式參數。
spaceDelimited | `array` | `query` | 空格分隔陣列值。此選項取代`collectionFormat`等同於`ssv`。 
pipeDelimited | `array` | `query` | Pipe分隔陣列值。此選項取代`collectionFormat`等同於`pipes`。
deepObject | `object` | `query` | 提供一個演繹使用表格參數巢狀物件的簡易方式。


##### 形式範例

假定一個命名為`color`的參數具備下列某一項值:

```
   string -> "blue"
   array -> ["blue","black","brown"]
   object -> { "R": 100, "G": 200, "B": 150 }
```
下列表格顯示這些值將如何被演繹的範例。

[`style`](#dataTypeFormat) | `explode` | `empty` | `string` | `array` | `object`
----------- | ------ | -------- | -------- | --------|-------
matrix | false | ;color | ;color=blue | ;color=blue,black,brown | ;color=R,100,G,200,B,150
matrix | true | ;color | ;color=blue | ;color=blue;color=black;color=brown | ;R=100;G=200;B=150
label | false | .  | .blue |  .blue.black.brown | .R.100.G.200.B.150
label | true | . | .blue |  .blue.black.brown | .R=100.G=200.B=150
form | false | color= | color=blue | color=blue,black,brown | color=R,100,G,200,B,150
form | true | color= | color=blue | color=blue&color=black&color=brown | R=100&G=200&B=150
simple | false | n/a | blue | blue,black,brown | R,100,G,200,B,150
simple | true | n/a | blue | blue,black,brown | R=100,G=200,B=150
spaceDelimited | false | n/a | n/a | blue%20black%20brown | R%20100%20G%20200%20B%20150
pipeDelimited | false | n/a | n/a | blue\|black\|brown | R\|100\|G\|200|G\|150
deepObject | true | n/a | n/a | n/a | color[R]=100&color[G]=200&color[B]=150

本物件可以由[規格擴充](#specificationExtensions)來進行擴充。 

##### 參數物件範例

一個具有64位元整數陣列的標頭參數:

```json
{
  "name": "token",
  "in": "header",
  "description": "token to be passed as a header",
  "required": true,
  "schema": {
    "type": "array",
    "items": {
      "type": "integer",
      "format": "int64"
    }
  },
  "style": "commaDelimited"
}
```

```yaml
name: token
in: header
description: token to be passed as a header
required: true
schema:
  type: array
  items:
    type: integer
    format: int64
style: commaDelimited
```

一組字串值的路徑參數:
```json
{
  "name": "username",
  "in": "path",
  "description": "username to fetch",
  "required": true,
  "schema": {
    "type": "string"
  }
}
```

```yaml
name: username
in: path
description: username to fetch
required: true
schema:
  type: string
```

一組可選擇字串值的查詢參數，藉由重覆查詢參數允許多類數值:
```json
{
  "name": "id",
  "in": "query",
  "description": "ID of the object to fetch",
  "required": false,
  "schema": {
    "type": "array",
    "items": {
      "type": "string"
    }
  },
  "style": "form",
  "explode": true
}
```

```yaml
name: id
in: query
description: ID of the object to fetch
required: false
schema:
  type: array
  items:
    type: string
style: form
explode: true
```

一組自由形式查詢參數，允許一特定類型的非定義參數:
```json
{
  "in": "query",
  "name": "freeForm",
  "schema": {
    "type": "object",
    "additionalProperties": {
      "type": "integer"
    },
  }
  "style": "form"
}
```

```yaml
in: query
name: freeForm
schema:
  type: object
  additionalProperties:
    type: integer
style: form
```

#### <a name="requestBodyObject"></a>Request Body物件
描述單一request body。

##### 固定欄位
欄位名稱 | 類型 | 描述
---|:---:|---
<a name="requestBodyDescription"></a>description | `string` | Request body的簡單描述。可以包含使用範例。為了富文字呈現，可以使用[CommonMark syntax](http://spec.commonmark.org/)。
<a name="requestBodyContent"></a>content | [Content Object](#contentObject) | Request body的內容。
<a name="requestBodyRequired"></a>required | `boolean` | 決定request body是否在要求中是必要的。預設為`true`。


本物件可以由[規格擴充](#specificationExtensions)來進行擴充。 

##### Request Body範例

具有引用模型定義的request body。
```json
{
  "description": "user to add to the system",
  "content": {
    "application/json": {
      "schema": {
        "$ref": "#/components/schemas/User"
      },
      "examples": [ "http://foo.bar/examples/user-example.json" ]
    },
    "application/xml": {
      "schema": {
        "$ref": "#/components/schemas/User"
      },
      "examples": [ "http://foo.bar/examples/user-example.xml" ]
    },
    "text/plain": {
      "examples": [ "http://foo.bar/examples/user-example.txt" ]
    },
    "*/*": {
      "example": {
        "$ref": "http://foo.bar/examples/user-example.whatever"
      }
    }
  }
}
```

```yaml
description: user to add to the system
content: 
  'application/json':
    schema:
      $ref: '#/components/schemas/User'
    examples:
      - 'http://foo.bar/examples/user-example.json'
  'application/xml':
    schema:
      $ref: '#/components/schemas/User'
    examples:
      - 'http://foo.bar/examples/user-example.xml'
  'text/plain':
    examples:
      - 'http://foo.bar/examples/user-example.txt'
  '*/*':
    example:
      $ref: 'http://foo.bar/examples/user-example.whatever'
```

為一組字串值陣列的body參數:
```json
{
  "description": "user to add to the system",
  "content": {
    "text/plain": {
      "schema": {
        "type": "array",
        "items": {
          "type": "string"
        }
      }
    }
  }
}
```

```yaml
description: user to add to the system
required: true
content:
  text/plain:
    schema:
      type: array
      items:
        type: string
```


#### <a name="contentObject"></a>內容物件

描述一組被支援的媒體類型設定。一組內容物件可以被用於[Request Body Object](#requestBody)，[Parameter Objects](#parameterObject)，[Header Objects](#headerObject)與[Response Objects](#responseObject).

在內容物件中的每個鑰匙是[Media Type Object](#mediaTypeObject)的媒體類型。

##### 內容範例

```js
"content": {
  "application/json": {
    "schema": {
      "type": "array",
      "items": {
        "type": "string"
      }
    },
    "examples": [
      ["Bob","Diane","Mary","Bill"],
      []
     ]
  },
  "application/xml": {
    "examples": [
      "<Users><User name='Bob'/><User name='Diane'/><User name='Mary'/><User name='Bill'/></Users>",
      "<Users/>"
    ]
  },
  "text/plain": {
    "Bob,Diane,Mary,Bill",
    ""
  }
}
```

```yaml
content:
  'application/json': 
    schema:
      type: array
      items:
        type: string
    examples:
      - 
        - Bob
        - Diane
        - Mary
        - Bill
      - {}

  'application/xml': 
    examples:
      - "<Users><User name='Bob'/><User name='Diane'/><User name='Mary'/><User name='Bill'/></Users>"
      - "<Users/>"
  'text/plain':
    examples:
      - "Bob,Diane,Mary,Bill"
```

#### <a name="mediaTypeObject"></a>媒體類型物件
每一個媒體類型物件由其鑰匙指定之媒體類型提供綱要與範例。媒體類型物件可以用於一組[內容物件](#contentObject)。   

##### 固定欄位
欄位名稱 | 類型 | 描述
---|:---:|---
<a name="mediaTypeSchema"></a>schema | [Schema Object](#schemaObject) <span>&#124;</span> [Reference Object](#referenceObject)] | 定義使用於request body之類型的綱要。
<a name="mediaTypeExamples"></a>examples | [[Example Object](#exampleObject) <span>&#124;</span> [Reference Object](#referenceObject)] | 媒體類型範例。在範例陣列中的每一個範例應該在正確的格式中，如在媒體類型中被指定一般。`examples`物件是與`example`物件相互排斥的。此外，如果引用包含一個範例的`schema`，`examples`值應該_override_ 由該綱要提供的範例。
<a name="mediaTypeExample"></a>example | [Example Object](#exampleObject) <span>&#124;</span> [Reference Object](#referenceObject) | 媒體類型範例。在範例陣列中的每一個範例應該在正確的格式中，如在媒體類型中被指定一般。`examples`物件是與`example`物件相互排斥的。此外，如果引用包含一個範例的`schema`，`examples`值應該_override_ 由該綱要提供的範例。
<a name="mediaTypeEncoding"></a>encoding | [Encoding Object](#encodingObject) | 媒體類型的編碼。當內容類型為`multipart`時，編碼物件應該僅應用於`requestBody`物件。

本物件可以由[規格擴充](#specificationExtensions)來進行擴充。 

##### 媒體類型範例

```js
{
  "application/json": {
    "schema": {
         "$ref": "#/components/schemas/Pet"
    },
    "examples": [{
                  "name": "Fluffy",
                  "petType": "Cat"
                 },
                 { 
                   "name": "Rover",
                   "petType": "Frog"
                 }]
  }
}
```

```yaml
application/json: 
  schema:
    $ref: "#/components/schemas/Pet"
  examples:
    # converted directly from YAML to JSON
    - name: Fluffy
      petType: Cat
    - {"name": "Rover", "petType": "Frog"}

```

##### 文件上載考量

與2.0規格相反，在OpenAPI中描述`file`輸入/輸出，如同任一其他綱要類型，是與相同語意同被描述的。
特別地是:

```yaml
# content transferred with base64 encoding
schema:
  type: string
  format: base64

# content transferred in binary (octet-stream):
schema:
  type: string
  format: binary
```

注意，前述範例不是應用於輸入酬載(例如，文件上載)就是回應酬載。

一個針對提交一份文件進入`POST`運算的`requestBody`範例可能看似如下:

```yaml
requestBody:
  content:
    application/octet-stream:
      # any media type is accepted, functionally equivalent to `*/*`
      schema:
        # a binary file of any type
        type: string
        format: binary
```

此外，特定媒體類型可能被指定為:

```yaml
# multiple, specific media types may be specified:
requestBody:
  content:
    'image/png, image/jpeg':
      # a binary file of type png or jpeg
      schema:
        type: string
        format: binary
```

##### 支援x-www-form-urlencoded request bodies

提交藉由RFC 1866編碼的表單url內容，可用下列定義:

```yaml
requestBody:
  content:
    x-www-form-urlencoded:
      schema:
        type: object
        properties:
          id:
            type: string
            format: uuid
          address:
            # complex types are stringified to support RFC1866
            type: object
            properties: {}
```

注意，在前述範例中，當正在傳遞到伺服器時，在`requestBody`的內容類型必須是每筆RFC1866字串化的。此外，`address`欄位複雜物件也將被字串化。

當在`x-www-form-urlencoded`內容類型中傳遞複雜物件時，如此屬性的預設序列化策略，如同`form`，是被描述於`parameterContent`區域中的。

##### 針對`multipart`內容的特別考量

當傳輸request bodies至運算時，通常利用`multipart/form-data`作為一組`Content-Type`。與2.0相反的是，當使用`multipart`內容時，要有一組`schema`來定義輸入參數至運算中。為了多種文件上載，允許複雜結構以及支援機制。

當在`multipart`類型中傳遞，臨界可以被用於分隔正在被傳輸內容的區域--因此，隨後的預設`Content-Type`是針對`multipart/*`而被定義的:

* 如果屬性是基本的，或一組基本值陣列，則預設Content-Type是`text/plain`
* 如果屬性是複雜的，或一組複雜值陣列，則預設Content-Type是`application/json`
* 如果屬性是一`type: string` with `format: binary` or `format: base64` (aka a file object)，則預設Content-Type是`application/octet-stream`


範例:

```yaml
requestBody:
  content:
    multipart/form-data:
      schema:
        type: object
        properties:
          id:
            type: string
            format: uuid
          address:
            # default Content-Type for objects is `application/json`
            type: object
            properties: {}
          profileImage:
            # default Content-Type for string/binary is `application/octet-stream`
            type: string
            format: binary
          children:
            # default Content-Type for arrays is based on the `inner` type (text/plain here)
            type: array
            items:
              type: string
          addresses:
            # default Content-Type for arrays is based on the `inner` type (object shown, so `application/json` in this example)
            type: array
            items:
              type: '#/components/schemas/Address'
```

在控制多於針對`multipart` request bodies的Content-Type所需的場景中，一項`encoding`屬性要被導入。這項屬性_only_可用於`multipart/*`與`x-www-form-urlencoded` request bodies。

#### <a name="encodingObject"></a>編碼物件

一個針對`requestBody`物件表示多重部分區域編碼的物件。

##### 態樣欄位
欄位態樣 | 類型 | 描述
---|:---:|---
<a name="encodingProperty"></a>{property} | [Encoding Property Object](#encodingPropertyObject) | 針對那些被用於特殊編碼的屬性名稱。此欄位必須在綱要中作為一屬性存在。

##### 編碼物件範例

```yaml
requestBody:
  content:
    multipart/mixed:
      schema:
        type: object
        properties:
          id:
            # default is text/plain
            type: string
            format: uuid
          address:
            # default is application/json
            type: object
            properties: {}
          historyMetadata:
            # need to declare XML format!
            description: metadata in XML format
            type: object
            properties: {}
          profileImage:
            # default is application/octet-stream, need to declare an image type only!
            type: string
            format: binary
      encoding:
        historyMetadata:
          # require XML Content-Type in utf-8 encoding
          contentType: application/xml; charset=utf-8
        profileImage:
          # only accept png/jpeg
          contentType: image/png, image/jpeg
```

#### <a name="encodingPropertyObject"></a>編碼屬性物件

應用於單一綱要屬性的單一編碼定義。

##### 固定欄位
欄位名稱 | 類型 | 描述
---|:---:|---
<a name="encodingContentType"></a>contentType | `string` | Content-Type用於編碼一特定屬性。預設值依照屬性類型: for `string` with `format` being `binary` - `application/octet-stream`; for other primitive types - `plain/text`; for `object` - `application/json`; for `array` - the default is defined based on the inner type.
<a name="encodingHeaders"></a>Headers | `object` | 一個允許額外資訊的字串地圖被提供為標頭，例如`Content-Disposition`。注意`Content-Type`是被分隔描述的並且從此區域中被忽略。
<a name="encodingStyle"></a>style | `string` | Content-Type用於編碼一特定屬性。在[`style`](#parameterStyle)屬性上的細節請見(#parameterContent)。 行為遵循針對`query`參數所允許的相同值，包含預設值。
<a name="encodingExplode"></a>explode | `boolean` | 當此為真時，類型`array`的屬性值或`object`針對陣列的每個值或地圖的鍵值對產生分隔參數。對其他屬性類型，此屬性沒有作用。當[`style`](#encodingStyle)是`form`時，預設值為`true`。對所有其他形式，預設值為`false`。

本物件可以由[規格擴充](#specificationExtensions)來進行擴充。 

#### <a name="responsesObject"></a>回應物件

針對一項運算預期回應的容器。
該容器繪製一項HTTP回應碼至預期的回應。
從文件中必然涵蓋所有可能的HTTP回應碼是不被預期的，只要他們不在事先已知。
然而，從文件涵蓋一組成功的運算回應和任何已知的錯誤是被預期的。

`default`可以被用來作為針對所有不被規範個別涵蓋的HTTP碼的預設回應物件。

`Responses Object`必須包含至少一項回應碼，並且應該為一項成功運算呼叫的回應。

##### 固定欄位
欄位名稱 | 類型 | 描述
---|:---:|---
<a name="responsesDefault"></a>default | [Response Object](#responseObject) <span>&#124;</span> [Reference Object](#referenceObject) | 除了針對特定HTTP回應碼宣告外的回應文件。
可以被用於涵蓋未宣告回應。
[Reference Object](#referenceObject)可以用於連結一項在[OpenAPI Object's responses](#oasResponses)區域上被定義的回應。

##### 態樣欄位
欄位態樣 | 類型 | 描述
---|:---:|---
<a name="responsesCode"></a>[HTTP Status Code](#httpCodes) | [Response Object](#responseObject) <span>&#124;</span> [Reference Object](#referenceObject) | 任一[HTTP status code](#httpCodes)可以被用為屬性名稱(一屬性一HTTP狀態碼)。描述該HTTP狀態碼的預期回應。[Reference Object](#referenceObject)可用於連結一項在[OpenAPI Object's responses](#oasResponses)區域上被定義的回應。為了JSON與YAML間的共通性，此欄位必須被引述(i.e. "200")，並且可以包含大寫字元，`X`指定一個使用型態通配字元，例如`2XX`為表示所有在`[200-299]`之間的HTTP狀態碼。
本物件可以由[規格擴充](#specificationExtensions)來進行擴充。 

##### 回應物件範例

一個針對成功運算的200反應以及一個針對其他的預設反應(暗示一個錯誤):

```json
{
  "200": {
    "description": "a pet to be returned",
    "content": {
      "application/json": {
        "schema": {
          "$ref": "#/components/schemas/Pet"
        }
      }
    }
  },
  "default": {
    "description": "Unexpected error",
    "content": {
      "application/json": {
        "schema": {
          "$ref": "#/components/schemas/ErrorModel"
        }
      }
    }
  }
}
```

```yaml
'200':
  description: a pet to be returned
  content: 
    application/json:
      schema:
        $ref: '#/components/schemas/Pet'
default:
  description: Unexpected error
  content:
    application/json:
      schema:
        $ref: '#/components/schemas/ErrorModel'
```

#### <a name="responseObject"></a>回應物件
描述一項API運算的單一回應，包含設計階段，指向依據回應運算的靜態`links`。

##### 固定欄位
欄位名稱 | 類型 | 描述
---|:---:|---
<a name="responseDescription"></a>description | `string` | **必要**。 回應的簡短描述。為了富文字呈現，可以使用[CommonMark syntax](http://spec.commonmark.org/)。
<a name="responseHeaders"></a>headers | [Headers Object](#headersObject) | 與回應同被發送的標頭名單。
<a name="responseContentObject"></a>content | [Content Object](#contentObject) | 一個包含潛在回應酬載描述的物件。
<a name="responseLinks"></a>links | [Links Object](#linksObject) | 一個表示與回應酬載有關運算的物件。

本物件可以由[規格擴充](#specificationExtensions)來進行擴充。 

##### 回應物件範例

一組複雜類型陣列的回應:

```json
{
  "description": "A complex object array response",
  "content": {
    "application/json": {
      "schema": {
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/VeryComplexType"
        }
      }
    }
  }
}
```

```yaml
description: A complex object array response
content: 
  application/json:
    schema: 
      type: array
      items:
        $ref: '#/components/schemas/VeryComplexType'
```

具備字串類型的回應:

```json
{
  "description": "A simple string response",
  "content": {
    "text/plain": {
      "schema": {
        "type": "string"
      }
    }
  }

}
```

```yaml
description: A simple string response
representations:
  text/plain:
    schema:
      type: string
```

具標頭的正常文字回應:

```json
{
  "description": "A simple string response",
  "content": {
    "text/plain": {
      "schema": {
        "type": "string"
      }
    }
  },
  "headers": {
    "X-Rate-Limit-Limit": {
      "description": "The number of allowed requests in the current period",
      "type": "integer"
    },
    "X-Rate-Limit-Remaining": {
      "description": "The number of remaining requests in the current period",
      "type": "integer"
    },
    "X-Rate-Limit-Reset": {
      "description": "The number of seconds left in the current period",
      "type": "integer"
    }
  }
}
```

```yaml
description: A simple string response
content:
  text/plain:
    schema:
      type: string
    example: 'whoa!'
headers:
  X-Rate-Limit-Limit:
    description: The number of allowed requests in the current period
    type: integer
  X-Rate-Limit-Remaining:
    description: The number of remaining requests in the current period
    type: integer
  X-Rate-Limit-Reset:
    description: The number of seconds left in the current period
    type: integer
```

具無返回值的回應:

```json
{
  "description": "object created"
}
```

```yaml
description: object created
```

#### <a name="callbacksObject"></a>回呼物件

關係到親本運算的可能頻外回呼的地圖。
地圖中的每個值是一組描述可能由API提供者與預期回應啟動的要求的[回呼物件](#callbackObject)。
用於確定回呼物件的關鍵值是一組在執行期被評估，確定一組使用於回呼運算URL的陳述。

##### 樣態欄位
欄位樣態 | 類型 | 描述
---|:---:|---
<a name="callbackName"></a>{name} | [Callback Object](#callbackObject) <span>&#124;</span> [Reference Object](#ReferenceObject) | 一組用於定義一回呼要求與預期回應的回呼物件。

本物件可以由[規格擴充](#specificationExtensions)來進行擴充。 

#### <a name="callbackObject"></a>回呼物件

關係到親本運算的可能頻外回呼的地圖。
地圖中的每個值是一組描述可能由API提供者與預期回應啟動的要求的[路徑項目物件](#pathItemObject)。
用於確定回呼物件的關鍵值是一組在執行期被評估，確定一組使用於回呼運算URL的陳述。

##### 樣態欄位
欄位樣態 | 類型 | 描述
---|:---:|---
<a name="callbackExpression"></a>{expression} | [Path Item Object](#pathItemObject) | 一組用於定義一回呼要求與預期回應的路徑項目物件。

本物件可以由[規格擴充](#specificationExtensions)來進行擴充。 

##### 關鍵陳述

用於確定[路徑項目物件](#pathItemObject)的關鍵是一組可以在執行HTTP要求/回應以確定為回呼要求而使用之URL的環境中可以被評估的變數陳述。
一組簡單範例可能是`$request.body#/url`。
然而，使用[variable substitution](#variableSubstitution)句法，可以取得完整的HTTP訊息。
這包含取得可以利用JSON Pointer[RFC6901](https://tools.ietf.org/html/rfc6901)所被取得的一個body的任一部分。 

例如，下列HTTP要求:

```http
POST /subscribe/myevent?queryUrl=http://clientdomain.com/stillrunning HTTP/1.1
Host: example.org
Content-Type: application/json
Content-Length: 123

{
  "failedUrl" : "http://clientdomain.com/failed"
  "successUrls : [
    "http://clientdomain.com/fast",
    "http://clientdomain.com/medium",
    "http://clientdomain.com/slow"
  ] 
}

201 Created
Location: http://example.org/subscription/1

```

此處為多樣陳述評估範例，假定一組回呼運算有一命名為`eventType`的路徑參述以及一組與命名為`queryUrl`的查詢參數。

陳述 | 值 
---|:---
$url | http://example.org/subscribe/myevent?queryUrl=http://clientdomain.com/stillrunning
$method | POST
$request.path.eventType | myevent
$request.query.queryUrl | http://clientdomain.com/stillrunning
$request.header.content-Type | application/json
$request.body#/failedUrl | http://clientdomain.com/stillrunning
$request.body#/successUrls/2 | http://clientdomain.com/medium
$response.header.Location | http://example.org/subscription/1


##### 回呼物件範例

一組針對由要求中`url`變數指定之URL的回呼


```yaml
myWebhook:
  '$request.body#/url':
    post:
      requestBody:
        description: Callback payload
        content: 
          'application/json'
            schema:
              $ref: '#/components/schemas/SomePayload'
      responses:
        200:
          description: webhook successfully processed an no retries will be performed
```


#### <a name="headersObject"></a> 標頭物件
列出可以在一回應被傳送或藉由一連結轉發的標頭。注意，[RFC 7230](https://tools.ietf.org/html/rfc7230#page-22) 聲明標頭名稱是大小寫有別的。

##### 樣態欄位
欄位樣態 | 類型 | 描述
---|:---:|---
<a name="headersName"></a>{name} | [Header Object](#headerObject)  <span>&#124;</span> [Reference Object](#referenceObject) | 對應之標投名稱之屬性名稱。該值描述標頭類型。

##### 標頭物件範例

限速標頭:

```json
{
    "X-Rate-Limit-Limit": {
        "description": "The number of allowed requests in the current period",
        "schema": {
            "type": "integer"
        }
    },
    "X-Rate-Limit-Remaining": {
        "description": "The number of remaining requests in the current period",
        "schema": {
            "type": "integer"
        }
    },
    "X-Rate-Limit-Reset": {
        "description": "The number of seconds left in the current period",
        "schema": {
            "type": "integer"
        }
    }
}
```

```yaml
X-Rate-Limit-Limit:
  description: The number of allowed requests in the current period
  schema:
    type: integer
X-Rate-Limit-Remaining:
  description: The number of remaining requests in the current period
  schema:
    type: integer
X-Rate-Limit-Reset:
  description: The number of seconds left in the current period
  schema:
    type: integer
```

#### <a name="exampleObject"></a>範例物件

允許分享運算要求與回應的範例。此物件或為自由形式物件、陣列，或為基本值。一組字串值可以被用於包含必要時跳脫範例，來表示在OpenAPI定義中不能被自然表示的媒體類型。 

##### 範例範例

一個Pet資料類型的應用/json媒體類型的範例呈現:

```json
  {
    "name": "Puma",
    "type": "Dog",
    "color": "Black",
    "gender": "Female",
    "breed": "Mixed"
  }
```

```yaml

name: Puma
type: Dog
color: Black
gender: Female
breed: Mixed

```

#### <a name="linksObject"></a>連結物件
連結物件代表一組可能針對一反應之設計階段連結。
一組連結的呈現不能保證該呼叫者成功調用之的能力，反而其提供在回應與其他運算間已知的關係以及穿越機制。

與_dynamic_連結(**in** 回應酬載中所被提供的連結)相反，OAS連結機制不需要在執行期於一特定回應格式中提供連結資訊。

為了運算連結，並且提供執行指令，[variable substitution](#variableSubstitution) 被用於取得一反應中的數值，並且當調用已連結運算時使用它們為數值。

##### 樣態欄位
欄位樣態 | 類型 | 描述
---|:---:|---
<a name="linkName"></a> {name} | [Link Object](#linkObject) <span>&#124;</span> [Reference Object](#referenceObject) | 該連結的簡短名稱，跟隨針對[元件物件](#componentsObject)的名稱的命名限制。
該連結應該參考單一連結物件，或一組單一連結物件之JSON參考。

#### <a name="#linkObject"></a> 連結物件
`Link Object`負責定義一組根據單一回應的可能運算。
欄位名稱  |  類型  | 描述
---|:---:|---
href        | `string`    | 指向一個已連結資源的一個相關或絕對URL。此欄位與`operationId`欄位是互為排斥的。
operationId | `string` | 一個 _existing_ 的名稱，可解決的OAS運算，作為一獨特 `operationId` 被訂定。此欄位與`href`欄位是互為排斥的。相關`href`值可以被用於定位一組在OAS中存在的[運算物件](#operationObject)。
parameters  | [Link Parameters Object](#linkParametersObject) | 一個代表參數的物件，傳遞至如`operationId`指定或藉由`href`確定的運算。
headers     | [Headers Object](#headersObject)    | 一個代表標頭的物件，傳遞至已連結資源。當這些標頭間產生衝突，並且在相關運算中定義，這些標頭會覆寫。
description | `string` | 連結的描述，支援[CommonMark syntax](http://spec.commonmark.org/)。

本物件可以由[規格擴充](#specificationExtensions)來進行擴充。 

定位一個已連結資源可以藉由`href`或`operationId`來被執行.
在`operationId`中，必須是在OAS文件範圍內獨特的並被解決的。
因為潛在的命名衝突，所以把`href`句法看作具外部參考規格的優先方法。

##### <a name="responsePayload"></a> 回應酬載值

酬載值僅在可以用符合通告媒體類型和可用JSON Pointer碎裂id引用資料類型的可剖析回應酬載中才是有用的。在所有的例子中，如果一項值_not_存在，則該參數將被視為一個`null`值(與empty值相反)並且 _not_ 作為一個指向已連結資源的參數來被傳遞。
當一項值是必要的案例裡，並且一項參數沒有被支援，客戶端可以選擇不要遵照連結定義。 

##### 範例

回應酬載:
```json
{
    "id": "df71a505-07bc-458a-a5c0-73c0340d1ec7",
    "firstname": "Ash",
    "lastname": "Williams"
}
```

酬載變數:
```yaml
id: df71a505-07bc-458a-a5c0-73c0340d1ec7
firstname: Ash
lastname: Williams
missingValue: null
```

變數出現在一組陣列的狀況中，一組變數的陣列將被截取。
例如:

```json
[
  { "color": "red" },
  { "color": "green" },
  { "color": "blue" }
]
```

將被如此截取:

```json
color: ["red", "green", "blue"]
```

產生的變數可以被用於由定義指示的位置中。


##### <a name="variableSubstitution"></a> 變數替代
在所有例子中，為了連結產生，從要求與回應而來的 _variables_ 可以被替代。
下示表格提供變數陳述範例與其在一個值中使用的範例:

資源位置 | 變數陳述 | 範例參考 | 注解
---|:---|:---|:---
HTTP Method            | `$method`         | `/users/{$method}`                | 針對`$method` 的允許值將是那些針對HTTP運算的值。 
Requested content type | `$request.header.accept`        | `/users/3?format={$request.header.accept}`      |  
Request parameter      | `$request.path.id`        | `/users/{$request.path.id}`            | 為了運算，要求參數必須在`parameters`區域被宣告或者它們無法被用於替代中。這包含要求標頭。
Request body           | `$request.body`    | `/users/{$request.body#/user/uuid}` | 針對接受酬載的運算，參考可以做為`requestBody`的部分或整個body本身。
Request URL            | `$url`            | `/track?url={$url}`               | 
Response value         | `$response.body`       | `{$response.body#/uuid}`                | 僅在回應中的酬載可以被`$response` 句法所取得。
Response header        | `$response.header` | `{$response.header.Server}`        | 僅單一標頭值可用。

從要求中，`parameter`在呼叫運算中的使用是藉由`$request`句法成為可用的。
針對回應，回應酬載可以具有 `$response` 句法來被使用。
針對要求與回應兩者，值將在由一變數陳述所指定區域中連結內將藉由大括弧`{}`圍繞被替代。 

變數陳述遵循[ABNF](https://tools.ietf.org/html/rfc5234)句法來被定義

```
      expression = ( "$url" | "$method" | "$request." [ source ] | "$response." [ source ])
      source = ( header-reference | query-reference | path-reference | body-reference )  
      header-reference = "header." token
      query-reference = "query." name  
      path-reference = "path." name
      body-reference = "body#" fragment
      fragment = a JSON Pointer [RFC 6901](https://tools.ietf.org/html/rfc6901)  
      name = *( char )
      char = as per RFC [7159](https://tools.ietf.org/html/rfc7159#section-7)
      token = as per RFC [7230](https://tools.ietf.org/html/rfc7230#section-3.2.6)
```

`name` 識別符是大小寫有別的，而`token`不是。 


##### 要求參數範例
運算來自要求運算的連結像如此:

```yaml
paths:
  /users/{id}:
    parameters:
    - name: id
      in: path
      required: true
      description: the user identifier, as userId or username
      schema:
        type: string
    responses:
      200:
        description: the user being returned
        content:
          application/json:
            schema:
              type: object
              properties:
                uuid: the unique user id
                  type: string
                  format: uuid
```

可以被用於一項連結中的類似如此:

```yaml
Addresses:
  href: '/users/{$request.path.id}/department'
```

當 `$request.path.id` 是在要求中傳遞給 `/users/{id}` 的值之處。
針對一個`10101110`的`id`值，產生的連結將會是:

```yaml
href: '/users/10101110/department'
```

##### 回應酬載範例

```yaml
Addresses:
  href: '/users/{$response.body#/uuid}/address'
```

當 `$response.uuid` 來自於前述案例會產生該目標:


```yaml
href: '/users/df71a505-07bc-458a-a5c0-73c0340d1ec7/address'
```

以及陣列範例:

```yaml
ColorSelection:
  href: 'http://colors.my-server.com/colors/{$response.body#/color}'
```

將產生下列連結:

```yaml
href: 'http://colors.my-server.com/colors/red'
href: 'http://colors.my-server.com/colors/green'
href: 'http://colors.my-server.com/colors/blue'
```

一如與所有連結相同，在客戶端的斟酌下遵循它們，並且允許與有能力使呼叫成功指向該連結不是藉由關係存在而被單獨保證的。


##### 範例

下列範例顯示在BitBucket API中的關係如何能被連結框架所呈現。此範例使用`operationId`值來連結回應至可能的運算。

```yaml
paths: 
  /2.0/users/{username}: 
    get: 
      operationId: getUserByName
      parameters: 
      - name: username
        in: path
        required: true
        schema:
          type: string
      responses: 
        200: 
          description: The User
          content:
            application/json:
              schema: 
                $ref: '#/components/schemas/user'
          links:
            userRepositories:
              $ref: '#/components/links/UserRepositories'
  /2.0/repositories/{username}:
    get:
      operationId: getRepositoriesByOwner
      parameters:
        - name: username
          in: path
          required: true
          schema:
            type: string
      responses:
        200:
          description: repositories owned by the supplied user
          content: 
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/repository'
          links:
            userRepository:
              $ref: '#/components/links/UserRepository'
  /2.0/repositories/{username}/{slug}: 
    get: 
      operationId: getRepository
      parameters: 
        - name: username
          type: string
          in: path
          required: true
          schema:
            type: string
        - name: slug
          in: path
          required: true
          schema:
            type: string
      responses: 
        200:
          description: The repository
            content:
              application/json: 
                schema: 
                  $ref: '#/components/schemas/repository'
          links:
            repositoryPullRequests:
              $ref: '#/components/links/RepositoryPullRequests'
  /2.0/repositories/{username}/{slug}/pullrequests: 
    get: 
      operationId: getPullRequestsByRepository
      parameters: 
      - name: username
        in: path
        required: true
        schema:
          type: string
      - name: slug
        in: path
        required: true
        schema:
          type: string
      - name: state
        in: query
        schema:
          type: string
          enum: 
            - open
            - merged
            - declined
      responses: 
        200: 
          description: an array of pull request objects
          content:
            application/json: 
              schema: 
                type: array
                items: 
                  $ref: '#/components/schemas/pullrequest'
  /2.0/repositories/{username}/{slug}/pullrequests/{pid}: 
    get: 
      operationId: getPullRequestsById
      parameters: 
      - name: username
        in: path
        required: true
        schema:
          type: string
      - name: slug
        in: path
        required: true
        schema:
          type: string
      - name: pid
        in: path
        required: true
        schema:
          type: string
      responses: 
        200: 
          description: a pull request object
          content:
            application/json: 
            schema: 
              $ref: '#/components/schemas/pullrequest'
          links:
            $ref: '#/components/links/PullRequestMerge'
  /2.0/repositories/{username}/{slug}/pullrequests/{pid}/merge: 
    post: 
      operationId: mergePullRequest
      parameters: 
      - name: username
        in: path
        required: true
        schema:
          type: string
      - name: slug
        in: path
        required: true
        schema:
          type: string
      - name: pid
        in: path
        required: true
        schema:
          type: string
      responses: 
        204:
          description: the PR was successfully merged
components:
  links:
    UserRepositories:
      # returns array of '#/components/schemas/repository'
      operationId: getRepositoriesByOwner
      parameters:
        username: $response.body#/username
    UserRepository:
      # returns '#/components/schemas/repository'
      operationId: getRepository
      parameters:
        username: $response.body#/owner/username
        slug: $response.body#/slug
    RepositoryPullRequests:
      # returns '#/components/schemas/pullrequest'
      operationId: getPullRequestsByRepository
        params: 
          username: $response.body#/owner/username
          slug: $response.body#/slug
    PullRequestMerge:
      # executes /2.0/repositories/{username}/{slug}/pullrequests/{pid}/merge
      operationId: mergePullRequest
      parameters:
        username: $response.body#/user/username # Should be $response.author.username?
        slug: $response.body#/repository/slug
        pid: $response.body#/id
  schemas: 
    user: 
      type: object
      properties: 
        username: 
          type: string
        uuid: 
          type: string
    repository: 
      type: object
      properties: 
        slug: 
          type: string
        owner: 
          $ref: '#/components/schemas/user'
    pullrequest: 
      type: object
      properties: 
        id: 
          type: integer
        title: 
          type: string
        repository: 
          $ref: '#/components/schemas/repository'
        author: 
          $ref: '#/components/schemas/user'
```

如同參考`operationId`可以不是可能的(`operationId`是可選擇值)，參考同樣可以藉由一相關`href`來製作:

```yaml
components:
  links:
    UserRepositories:
      # returns array of '#/components/schemas/repository'
      href: '/2.0/repositories/{$response.body#/username}'
```

或一個絕對 `href`:

```yaml
components:
  links:
    UserRepositories:
      # returns array of '#/components/schemas/repository'
      href: 'https://na2.gigantic-server.com/2.0/repositories/{$response.body#/username}'
```


#### <a name="linkParametersObject"></a> 連結參數物件
使用`operationId` 來涉及一項在定義中的運算有許多益處，包含定義媒體類型選項、安全需求、回應與錯誤酬載的能力。
許多運算需要參數被傳遞，而依據回應本身這些參數可以是動態的。

我們可以使用**Link Parameters Object** 來指定運算所需的參數。
此物件包含伴隨靜態或動態值的參數名稱:

##### 樣態欄位
樣態欄位 | 類型 | 描述
---|:---:|---
<a name="linkParameterName"></a> {name} | Any <span>&#124;</span> [{expression}](#variableSubstitution) | 用於評估與傳遞至已連結運算的一個常量值或陳述。

```yaml
paths:
  /user/{username}: # ...
  /user/{username}/commits:
    get:
      operationId: userCommitHistory
      parameters:
      - name: username
        in: path
        type: string
        required: true
      - name: page
        type: integer
        format: int32
        required: true
      responses: { ... }
components:
  links:
    UserCommitHistory:
      operationId: userCommitHistory
      parameters:
        username: $response.body#/user/username
        page: 0
```

在前述內容中，`UserCommitHistory` 的連結指向 `getUserCommitHistory` 運算，並且從回應酬載以及在靜態純量字串值`0`之上傳遞`username`值。

#### <a name="headerObject"></a> 標頭物件

標頭物件遵照[參數物件](#parameterObject) 的結構，具以下改變:

1. `name` 必須不被指定，是在[標頭物件](#headersObject)中被給定.
1. `in` 必須不被指定，是隱含於`header`中.
1. 所有藉由位置起作用的特徵必須遵照`header`的位置(例如, [`style`](#parameterStyle)).

##### 標頭物件範例

一項具整數類型的簡單標頭:

```json
{
  "description": "The number of allowed requests in the current period",
  "schema": {
    "type": "integer"
  }
}
```

```yaml
description: The number of allowed requests in the current period
schema:
  type: integer
```

#### <a name="tagObject"></a>標籤物件

允許附加詮釋資料至[Operation Object](#operationObject) 所使用之單一標籤。
每一個被使用的標籤非強制性要有一個標籤物件。

##### 固定欄位
欄位名稱 | 類型 | 描述
---|:---:|---
<a name="tagName"></a>name | `string` | **必要**。標籤名稱。
<a name="tagDescription"></a>description | `string` | 標籤的簡短描述。為了富文字呈現，可以使用[CommonMark syntax](http://spec.commonmark.org/)。
<a name="tagExternalDocs"></a>externalDocs | [External Documentation Object](#externalDocumentationObject) | 此標籤之額外外部文件。

本物件可以由[規格擴充](#specificationExtensions)來進行擴充。 

##### 標籤物件範例

```json
{
	"name": "pet",
	"description": "Pets operations"
}
```

```yaml
name: pet
description: Pets operations
```

#### <a name="examplesObject"></a> 範例物件

一個 `example` 可能被給定的任何地方，可以使用一組JSON Reference，有明顯限制說明有具有物件名為 `$ref` 的JSON格式的範例是不被允許的。不表示結構上 `example` 可以或為一字串基本值或一物件，這點與 `additionalProperties` 相似。

在所有例子中，酬載被預期與隨同值的類型綱要是相容的。加工執行可以選擇自動驗證相容性，並且拒絕無法相容的範例值。

```yaml
# in a model
schemas:
  properties:
    name:
      type: string
      example:
        $ref: http://foo.bar#/examples/name-example

# in a request body, note the plural `examples` as the Content-Type is set to `*`:
  requestBody:
    content:
      'application/json':
        schema:
          $ref: '#/components/schemas/Address'
        examples: 
          - {"foo": "bar"}
          - {"bar": "baz"}
      'application/xml':
        examples: 
          - $ref: 'http://foo.bar#/examples/address-example.xml' 
      'text/plain':
        examples: 
          - $ref: 'http://foo.bar#/examples/address-example.txt' 
        
# in a parameter

  parameters:
    - name: 'zipCode'
      in: 'query'
      schema:
        type: 'string'
        format: 'zip-code'
        example: 
          $ref: 'http://foo.bar#/examples/zip-example'
# in a response, note the plural `examples`:
  responses:
    200:
      description: your car appointment has been booked
      content: 
        application/json:
          schema:
            $ref: '#/components/schemas/SuccessResponse'
          example:
            $ref: http://foo.bar#/examples/address-example.json
```

#### <a name="referenceObject"></a> 參考物件

一個在內部與外部上允許在規格中引用其他元件的簡單物件。

參考物件由[JSON Reference](https://tools.ietf.org/html/draft-pbryan-zyp-json-ref-03) 所定義並且遵照相同結構、行為與規則。 

針對此規格，如JSON Reference規格所定義與不被定義的，參考解決方案已經完成。

##### 固定欄位
欄位名稱 | 類型 | 描述
---|:---:|---
<a name="referenceRef"></a>$ref | `string` | **必要**。 參考字串。 

此物件不能擴充額外屬性並且任何附加屬性應該被忽略。

##### 參考物件範例

```json
{
	"$ref": "#/components/schemas/Pet"
}
```

```yaml
$ref: '#/components/schemas/Pet'
```

##### 相關框架文件範例
```json
{
  "$ref": "Pet.json"
}
```

```yaml
$ref: Pet.yaml
```

##### 具嵌入綱要相關文件範例
```json
{
  "$ref": "definitions.json#/Pet"
}
```

```yaml
$ref: definitions.yaml#/Pet
```

#### <a name="schemaObject"></a>綱要物件

綱要物件允許輸入與輸出資料類型的定義。
這些類型可以為物件，也可為基本值或陣列。
此物件為[JSON Schema Specification Wright Draft 00](http://json-schema.org/)的擴充子集。

有關屬性的進一步資訊可見[JSON Schema Core](https://tools.ietf.org/html/draft-wright-json-schema-00)與[JSON Schema Validation](https://tools.ietf.org/html/draft-wright-json-schema-validation-00)。
除非已聲明，否則屬性定義遵照如此處引用之JSON Schema規格。

下列屬性直接取自於JSON Schema定義並且遵照相同規格:

- title
- multipleOf
- maximum
- exclusiveMaximum
- minimum
- exclusiveMinimum
- maxLength
- minLength
- pattern
- maxItems
- minItems
- uniqueItems
- maxProperties
- minProperties
- required
- enum

下列屬性取自於JSON Schema定義但是其定義已調整符合OpenAPI規格。 
- type - 值必須是一字串。經由一組陣列的多類型不被支援。
- allOf - 內嵌或引用的綱要必須是[綱要物件](#schemaObject) 並且不是標準JSON Schema。
- oneOf - 內嵌或引用的綱要必須是[綱要物件](#schemaObject) 並且不是標準JSON Schema。
- anyOf - 內嵌或引用的綱要必須是[綱要物件](#schemaObject) 並且不是標準JSON Schema。
- not - 內嵌或引用的綱要必須是[綱要物件](#schemaObject) 並且不是標準JSON Schema。
- items - 值必須是一物件並且不是一組陣列。內嵌或引用的綱要必須是[綱要物件](#schemaObject) 並且不是標準JSON Schema。如果 `type`是`array` ，`items`必須呈現。
- properties - 屬性定義必須是[綱要物件](#schemaObject) 並且不是標準JSON Schema (內嵌或引用).
- additionalProperties - 值可以是布林或物件。內嵌或引用的綱要必須是[綱要物件](#schemaObject) 並且不是標準JSON Schema。
- description - 為了富文字呈現，可以使用[CommonMark syntax](http://spec.commonmark.org/)。
- format - 進一步細節參見[Data Type Formats](#dataTypeFormat)。 While relying on JSON Schema's defined formats, the OAS offers a few additional predefined formats.
- default - The default value represents what would be assumed by the consumer of the input as the value of the schema if one is not provided. Unlike JSON Schema, the value MUST conform to the defined type for the Schema Object defined at the same level. For example, of `type` is `string`, then `default` can be `"foo"`` but cannot be `1`.

Alternatively, any time a Schema Object can be used, a [Reference Object](#referenceObject) can be used in its place. This allows referencing definitions in place of defining them inline.

Additional properties defined by the JSON Schema specification that are not mentioned here are strictly unsupported.

Other than the JSON Schema subset fields, the following fields MAY be used for further schema documentation:

##### Fixed Fields
Field Name | Type | Description
---|:---:|---
<a name="schemaNullable"></a>nullable | `boolean` | Allows sending a `null` value for the defined schema. Default value is `false`.
<a name="schemaDiscriminator"></a>discriminator | `string` | Adds support for polymorphism. The discriminator is the schema property name that is used to differentiate between other schema that inherit this schema. The property name used MUST be defined at this schema and it MUST be in the `required` property list. When used, the value MUST be the name of this schema or any schema that inherits it. See [Composition and Inheritance](#schemaComposition) for more details.
<a name="schemaReadOnly"></a>readOnly | `boolean` | Relevant only for Schema `"properties"` definitions. Declares the property as "read only". This means that it MAY be sent as part of a response but SHOULD NOT be sent as part of the request. If property is marked as `readOnly` being `true` and is in the `required` list, the `required` will take effect on the response only. A property MUST NOT be marked as both `readOnly` and `writeOnly` being `true`. Default value is `false`.
<a name="schemaWriteOnly"></a>writeOnly | `boolean` | Relevant only for Schema `"properties"` definitions. Declares the property as "write only". This means that it MAY be sent as part of a request but SHOULD NOT be sent as part of the response. If property is marked as `writeOnly` being `true` and is in the `required` list, the `required` will take effect on the request only. A property MUST NOT be marked as both `readOnly` and `writeOnly` being `true`. Default value is `false`.
<a name="schemaXml"></a>xml | [XML Object](#xmlObject) | This MAY be used only on properties schemas. It has no effect on root schemas. Adds Additional metadata to describe the XML representation format of this property.
<a name="schemaExternalDocs"></a>externalDocs | [External Documentation Object](#externalDocumentationObject) | Additional external documentation for this schema. 
<a name="schemaExample"></a>example | Any | A free-form property to include an example of an instance for this schema.
<a name="schemaExamples"></a>examples | Any | An array of free-formed properties to include examples for this schema.
<a name="schemaDeprecated"></a> deprecated | `boolean` | Specifies that a schema is deprecated and SHOULD be transitioned out of usage.

This object can be extended with [Specification Extensions](#specificationExtensions). 

###### <a name="schemaComposition"></a>Composition and Inheritance (Polymorphism)

The OpenAPI Specification allows combining and extending model definitions using the `allOf` property of JSON Schema, in effect offering model composition.
`allOf` takes in an array of object definitions that are validated *independently* but together compose a single object. 

While composition offers model extensibility, it does not imply a hierarchy between the models.
To support polymorphism, OpenAPI Specification adds the support of the `discriminator` field.
When used, the `discriminator` will be the name of the property used to decide which schema definition is used to validate the structure of the model.
As such, the `discriminator` field MUST be a required field.
There are are two ways to define the value of a discriminator for an inheriting instance.
- Use the schema's name.
- Override the schema's name by overriding the property with a new value. If exists, this takes precedence over the schema's name.
As such, inline schema definitions, which do not have a given id, *cannot* be used in polymorphism.

###### XML Modeling

The [xml](#schemaXml) property allows extra definitions when translating the JSON definition to XML.
The [XML Object](#xmlObject) contains additional information about the available options.

##### Schema Object Examples

###### Primitive Sample

```json
{
  "type": "string",
  "format": "email"
}
```

```yaml
type: string
format: email
```

###### Simple Model

```json
{
  "type": "object",
  "required": [
    "name"
  ],
  "properties": {
    "name": {
      "type": "string"
    },
    "address": {
      "$ref": "#/components/schemas/Address"
    },
    "age": {
      "type": "integer",
      "format": "int32",
      "minimum": 0
    }
  }
}
```

```yaml
type: object
required:
- name
properties:
  name:
    type: string
  address:
    $ref: '#/components/schemas/Address'
  age:
    type: integer
    format: int32
    minimum: 0
```

###### Model with Map/Dictionary Properties

For a simple string to string mapping:

```json
{
  "type": "object",
  "additionalProperties": {
    "type": "string"
  }
}
```

```yaml
type: object
additionalProperties:
  type: string
```

For a string to model mapping:

```json
{
  "type": "object",
  "additionalProperties": {
    "$ref": "#/components/schemas/ComplexModel"
  }
}
```

```yaml
type: object
additionalProperties:
  $ref: '#/components/schemas/ComplexModel'
```

###### Model with Example

```json
{
  "type": "object",
  "properties": {
    "id": {
      "type": "integer",
      "format": "int64"
    },
    "name": {
      "type": "string"
    }
  },
  "required": [
    "name"
  ],
  "example": {
    "name": "Puma",
    "id": 1
  }
}
```

```yaml
type: object
properties:
  id:
    type: integer
    format: int64
  name:
    type: string
required:
- name
example:
  name: Puma
  id: 1
```

###### Model with Examples

```json
{
  "type": "object",
  "properties": {
    "id": {
      "type": "integer",
      "format": "int64"
    },
    "name": {
      "type": "string"
    }
  },
  "required": [
    "name"
  ],
  "examples": [
  {
    "name": "Puma",
    "id": 1
  }, {
    "name": "Ferguson",
    "id": 2
  }]
}
```

```yaml
type: object
properties:
  id:
    type: integer
    format: int64
  name:
    type: string
required:
- name
examples:
  - name: Puma
    id: 1
  - name: Ferguson
    id: 2
```

###### Models with Composition

```json
{
  "schemas": {
    "ErrorModel": {
      "type": "object",
      "required": [
        "message",
        "code"
      ],
      "properties": {
        "message": {
          "type": "string"
        },
        "code": {
          "type": "integer",
          "minimum": 100,
          "maximum": 600
        }
      }
    },
    "ExtendedErrorModel": {
      "allOf": [
        {
          "$ref": "#/components/schemas/ErrorModel"
        },
        {
          "type": "object",
          "required": [
            "rootCause"
          ],
          "properties": {
            "rootCause": {
              "type": "string"
            }
          }
        }
      ]
    }
  }
}
```

```yaml
schemas:
  ErrorModel:
    type: object
    required:
    - message
    - code
    properties:
      message:
        type: string
      code:
        type: integer
        minimum: 100
        maximum: 600
  ExtendedErrorModel:
    allOf:
    - $ref: '#/components/schemas/ErrorModel'
    - type: object
      required:
      - rootCause
      properties:
        rootCause:
          type: string
```

###### Models with Polymorphism Support

```json
{
  "schemas": {
    "Pet": {
      "type": "object",
      "discriminator": "petType",
      "properties": {
        "name": {
          "type": "string"
        },
        "petType": {
          "type": "string"
        }
      },
      "required": [
        "name",
        "petType"
      ]
    },
    "Cat": {
      "description": "A representation of a cat. Note that `Cat` will be used as the discriminator value.",
      "allOf": [
        {
          "$ref": "#/components/schemas/Pet"
        },
        {
          "type": "object",
          "properties": {
            "huntingSkill": {
              "type": "string",
              "description": "The measured skill for hunting",
              "default": "lazy",
              "enum": [
                "clueless",
                "lazy",
                "adventurous",
                "aggressive"
              ]
            }
          },
          "required": [
            "huntingSkill"
          ]
        }
      ]
    },
    "Dog": {
      "description": "A representation of a dog. Note that `Dog` will be used as the discriminator value.",
      "allOf": [
        {
          "$ref": "#/components/schemas/Pet"
        },
        {
          "type": "object",
          "properties": {
            "packSize": {
              "type": "integer",
              "format": "int32",
              "description": "the size of the pack the dog is from",
              "default": 0,
              "minimum": 0
            }
          },
          "required": [
            "packSize"
          ]
        }
      ]
    }
  }
}
```

```yaml
schemas:
  Pet:
    type: object
    discriminator: petType
    properties:
      name:
        type: string
      petType:
        type: string
    required:
    - name
    - petType
  Cat:  ## "Cat" will be used as the discriminator value
    description: A representation of a cat
    allOf:
    - $ref: '#/components/schemas/Pet'
    - type: object
      properties:
        huntingSkill:
          type: string
          description: The measured skill for hunting
          default: lazy
          enum:
          - clueless
          - lazy
          - adventurous
          - aggressive
      required:
      - huntingSkill
  Dog:  ## "Dog" will be used as the discriminator value
    description: A representation of a dog
    allOf:
    - $ref: '#/components/schemas/Pet'
    - type: object
      properties:
        packSize:
          type: integer
          format: int32
          description: the size of the pack the dog is from
          default: 0
          minimum: 0
      required:
      - packSize
```

#### <a name="xmlObject"></a>XML Object

A metadata object that allows for more fine-tuned XML model definitions.

When using arrays, XML element names are *not* inferred (for singular/plural forms) and the `name` property SHOULD be used to add that information.
See examples for expected behavior.

##### Fixed Fields
Field Name | Type | Description
---|:---:|---
<a name="xmlName"></a>name | `string` | Replaces the name of the element/attribute used for the described schema property. When defined within `items`, it will affect the name of the individual XML elements within the list. When defined alongside `type` being `array` (outside the `items`), it will affect the wrapping element and only if `wrapped` is `true`. If `wrapped` is `false`, it will be ignored.
<a name="xmlNamespace"></a>namespace | `string` | The URL of the namespace definition. Value SHOULD be in the form of a URL.
<a name="xmlPrefix"></a>prefix | `string` | The prefix to be used for the [name](#xmlName).
<a name="xmlAttribute"></a>attribute | `boolean` | Declares whether the property definition translates to an attribute instead of an element. Default value is `false`.
<a name="xmlWrapped"></a>wrapped | `boolean` | MAY be used only for an array definition. Signifies whether the array is wrapped (for example, `<books><book/><book/></books>`) or unwrapped (`<book/><book/>`). Default value is `false`. The definition takes effect only when defined alongside `type` being `array` (outside the `items`).

This object can be extended with [Specification Extensions](#specificationExtensions). 

##### XML Object Examples

The examples of the XML object definitions are included inside a property definition of a [Schema Object](#schemaObject) with a sample of the XML representation of it.

###### No XML Element

Basic string property:

```json
{
    "animals": {
        "type": "string"
    }
}
```

```yaml
animals:
  type: string
```

```xml
<animals>...</animals>
```

Basic string array property ([`wrapped`](#xmlWrapped) is `false` by default):

```json
{
    "animals": {
        "type": "array",
        "items": {
            "type": "string"
        }
    }
}
```

```yaml
animals:
  type: array
  items:
    type: string
```

```xml
<animals>...</animals>
<animals>...</animals>
<animals>...</animals>
```

###### XML Name Replacement

```json
{
  "animals": {
    "type": "string",
    "xml": {
      "name": "animal"
    }
  }
}
```

```yaml
animals:
  type: string
  xml:
    name: animal
```

```xml
<animal>...</animal>
```


###### XML Attribute, Prefix and Namespace

In this example, a full model definition is shown.

```json
{
  "Person": {
    "type": "object",
    "properties": {
      "id": {
        "type": "integer",
        "format": "int32",
        "xml": {
          "attribute": true
        }
      },
      "name": {
        "type": "string",
        "xml": {
          "namespace": "http://example.com/schema/sample",
          "prefix": "sample"
        }
      }
    }
  }
}
```

```yaml
Person:
  type: object
  properties:
    id:
      type: integer
      format: int32
      xml:
        attribute: true
    name:
      type: string
      xml:
        namespace: http://example.com/schema/sample
        prefix: sample
```

```xml
<Person id="123">
    <sample:name xmlns:sample="http://example.com/schema/sample">example</sample:name>
</Person>
```

###### XML Arrays

Changing the element names:

```json
{
  "animals": {
    "type": "array",
    "items": {
      "type": "string",
      "xml": {
        "name": "animal"
      }
    }
  }
}
```

```yaml
animals:
  type: array
  items:
    type: string
    xml:
      name: animal
```

```xml
<animal>value</animal>
<animal>value</animal>
```

The external `name` property has no effect on the XML:

```json
{
  "animals": {
    "type": "array",
    "items": {
      "type": "string",
      "xml": {
        "name": "animal"
      }
    },
    "xml": {
      "name": "aliens"
    }
  }
}
```

```yaml
animals:
  type: array
  items:
    type: string
    xml:
      name: animal
  xml:
    name: aliens
```

```xml
<animal>value</animal>
<animal>value</animal>
```

Even when the array is wrapped, if no name is explicitly defined, the same name will be used both internally and externally:

```json
{
  "animals": {
    "type": "array",
    "items": {
      "type": "string"
    },
    "xml": {
      "wrapped": true
    }
  }
}
```

```yaml
animals:
  type: array
  items:
    type: string
  xml:
    wrapped: true
```

```xml
<animals>
  <animals>value</animals>
  <animals>value</animals>
</animals>
```

To overcome the above example, the following definition can be used:

```json
{
  "animals": {
    "type": "array",
    "items": {
      "type": "string",
      "xml": {
        "name": "animal"
      }
    },
    "xml": {
      "wrapped": true
    }
  }
}
```

```yaml
animals:
  type: array
  items:
    type: string
    xml:
      name: animal
  xml:
    wrapped: true
```

```xml
<animals>
  <animal>value</animal>
  <animal>value</animal>
</animals>
```

Affecting both internal and external names:

```json
{
  "animals": {
    "type": "array",
    "items": {
      "type": "string",
      "xml": {
        "name": "animal"
      }
    },
    "xml": {
      "name": "aliens",
      "wrapped": true
    }
  }
}
```

```yaml
animals:
  type: array
  items:
    type: string
    xml:
      name: animal
  xml:
    name: aliens
    wrapped: true
```

```xml
<aliens>
  <animal>value</animal>
  <animal>value</animal>
</aliens>
```

If we change the external element but not the internal ones:

```json
{
  "animals": {
    "type": "array",
    "items": {
      "type": "string"
    },
    "xml": {
      "name": "aliens",
      "wrapped": true
    }
  }
}
```

```yaml
animals:
  type: array
  items:
    type: string
  xml:
    name: aliens
    wrapped: true
```

```xml
<aliens>
  <aliens>value</aliens>
  <aliens>value</aliens>
</aliens>
```

#### <a name="securitySchemeObject"></a>Security Scheme Object

Allows the definition of a security scheme that can be used by the operations.
Supported schemes are HTTP authentication, an API key (either as a header or as a query parameter) and OAuth2's common flows (implicit, password, application and access code).

##### Fixed Fields
Field Name | Type | Validity | Description
---|:---:|---|---
<a name="securitySchemeType"></a>type | `string` | Any | **Required.** The type of the security scheme. Valid values are `"apiKey"`, `"http"`, `"oauth2"`, `"openIdConnect"`.
<a name="securitySchemeDescription"></a>description | `string` | Any | A short description for security scheme.
<a name="securitySchemeName"></a>name | `string` | `apiKey` | **Required.** The name of the header or query parameter to be used.
<a name="securitySchemeIn"></a>in | `string` | `apiKey` | **Required.** The location of the API key. Valid values are `"query"` or `"header"`.
<a name="securitySchemeScheme"></a>scheme | `string` | `http` | **Required.** The name of the HTTP Authorization scheme to be used in the [Authorization header as defined in RFC 7235](https://tools.ietf.org/html/rfc7235#section-4.2).
<a name="securitySchemeBearerFormat"></a>bearerFormat | `string` | `http` (`"bearer"`) | A hint to the client to identify how the bearer token is formatted.  Bearer tokens are usually generated by an authorization server, so this information is primarily for documentation purposes.
<a name="securitySchemeFlow"></a>flow | [OAuth Flows Object](#oauthFlowsObject) | `oauth2` | **Required.** An object containing configuration information for the flow types supported. 
<a name="securitySchemeOpenIdConnectUrl"></a>openIdConnectUrl | `string` | `openIdConnect` | **Required.** OpenId Connect URL to discover OAuth2 configuration values. This MUST be in the form of a URL. 

This object can be extended with [Specification Extensions](#specificationExtensions). 

##### Security Scheme Object Example

###### Basic Authentication Sample

```json
{
  "type": "http",
  "scheme": "basic"
}
```

```yaml
type: http
scheme: basic
```

###### API Key Sample

```json
{
  "type": "apiKey",
  "name": "api_key",
  "in": "header"
}
```

```yaml
type: apiKey
name: api_key
in: header
```

###### JWT Bearer Sample

```json
{
  "type": "scheme",
  "scheme": "bearer",
  "bearerFormat": "JWT",
}
```

```yaml
type: http
scheme: bearer
bearerFormat: JWT
```

###### Implicit OAuth2 Sample

```json
{
  "type": "oauth2",
  "flow": {
    "implicit": {
      "authorizationUrl": "https://example.com/api/oauth/dialog",
      "scopes": {
        "write:pets": "modify pets in your account",
        "read:pets": "read your pets"
      }
    }
  }
}
```

```yaml
type: oauth2
flow: 
  implicit:
    authorizationUrl: https://example.com/api/oauth/dialog
    scopes:
      write:pets: modify pets in your account
      read:pets: read your pets
```

#### <a name="oauthFlowsObject"></a>OAuth Flows Object

Allows configuration of the supported OAuth Flows.

##### Fixed Fields
Field Name | Type | Description
---|:---:|---|---
<a name="oauthFlowImplicit"></a>implicit| [OAuth Flow Object](#oauthFlowObject) | Configuration for the OAuth Implicit flow 
<a name="oauthFlowPassword"></a>password| [OAuth Flow Object](#oauthFlowObject) | Configuration for the OAuth Resource Owner Password flow 
<a name="oauthFlowClientCredentials"></a>clientCredentials| [OAuth Flow Object](#oauthFlowObject) | Configuration for the OAuth Client Credentials flow.  Previously called `application` in OpenAPI 2.0.
<a name="oauthFlowAuthorizationCode"></a>authorizationCode| [OAuth Flow Object](#oauthFlowObject) | Configuration for the OAuth Authorization Code flow.  Previously called `accessCode` in OpenAPI 2.0.

This object can be extended with [Specification Extensions](#specificationExtensions). 

#### <a name="oauthFlowObject"></a>OAuth Flow Object

Configuration details for a supported OAuth Flow

##### Fixed Fields
Field Name | Type | Validity | Description
---|:---:|---|---
<a name="securitySchemeAuthorizationUrl"></a>authorizationUrl | `string` | `oauth2` (`"implicit"`, `"authorizationCode"`) | **Required.** The authorization URL to be used for this flow. This MUST be in the form of a URL.
<a name="securitySchemeTokenUrl"></a>tokenUrl | `string` | `oauth2` (`"password"`, `"clientCredentials"`, `"authorizationCode"`) | **Required.** The token URL to be used for this flow. This MUST be in the form of a URL.
<a name="securitySchemeRefreshUrl"></a>refreshUrl | `string` | `oauth2` | The URL to be used for obtaining refresh tokens. This MUST be in the form of a URL.
<a name="securitySchemeScopes"></a>scopes | [Scopes Object](#scopesObject) | `oauth2` | **Required.** The available scopes for the OAuth2 security scheme.

This object can be extended with [Specification Extensions](#specificationExtensions). 

##### OAuth Flow Object Examples

```JSON
{
  "type": "oauth2",
  "flow": {
    "implicit": {
      "authorizationUrl": "https://example.com/api/oauth/dialog",
      "scopes": {
        "write:pets": "modify pets in your account",
        "read:pets": "read your pets"
      }
    },
    "authorizationCode": {
      "authorizationUrl": "https://example.com/api/oauth/dialog",
      "tokenUrl": "https://example.com/api/oauth/token",
      "scopes": {
        "write:pets": "modify pets in your account",
        "read:pets": "read your pets"
      }
    }
  }
}
```

```YAML
type: oauth2
flow: 
  implicit:
    authorizationUrl: https://example.com/api/oauth/dialog
    scopes:
      write:pets: modify pets in your account
      read:pets: read your pets
  authorizationCode:
    authorizationUrl: https://example.com/api/oauth/dialog
    tokenUrl: https://example.com/api/oauth/token
    scopes:
      write:pets: modify pets in your account
      read:pets: read your pets 
```

#### <a name="scopesObject"></a>Scopes Object

Lists the available scopes for an OAuth2 security scheme.

##### Patterned Fields

Field Pattern | Type | Description
---|:---:|---
<a name="scopesName"></a>{name} | `string` | Maps between a name of a scope to a short description of it (as the value of the property).

This object can be extended with [Specification Extensions](#specificationExtensions). 

##### Scopes Object Example

```json
{
  "write:pets": "modify pets in your account",
  "read:pets": "read your pets"
}
```

```yaml
write:pets: modify pets in your account
read:pets: read your pets
```

#### <a name="securityRequirementObject"></a>Security Requirement Object

Lists the required security schemes to execute this operation.
The name used for each property MUST correspond to a security scheme declared in the [Security Schemes](#componentsSecuritySchemes) under the [Components Object](#componentsObject).

Security Requirement Objects that contain multiple schemes require that all schemes MUST be satisfied for a request to be authorized.
This enables support for scenarios where there multiple query parameters or HTTP headers are required to convey security information.

When a list of Security Requirement Objects is defined on the [Open API object](#oasObject) or [Operation Object](#operationObject), only one of Security Requirement Objects in the list needs to be satisfied to authorize.  

##### Patterned Fields

Field Pattern | Type | Description
---|:---:|---
<a name="securityRequirementsName"></a>{name} | [`string`] | Each name MUST correspond to a security scheme which is declared in the [Security Schemes](#componentsSecuritySchemes) under the [Components Object](#componentsObject). If the security scheme is of type `"oauth2"` or `"openIdConnect"`, then the value is a list of scope names required for the execution. For other security scheme types, the array MUST be empty.

##### Security Requirement Object Examples

###### Non-OAuth2 Security Requirement

```json
{
  "api_key": []
}
```

```yaml
api_key: []
```

###### OAuth2 Security Requirement

```json
{
  "petstore_auth": [
    "write:pets",
    "read:pets"
  ]
}
```

```yaml
petstore_auth:
- write:pets
- read:pets
```

### <a name="specificationExtensions"></a>Specification Extensions

While the OpenAPI Specification tries to accommodate most use cases, additional data can be added to extend the specification at certain points.

The extensions properties are implemented as patterned fields that are always prefixed by `"x-"`.

Field Pattern | Type | Description
---|:---:|---
<a name="infoExtensions"></a>^x- | Any | Allows extensions to the OpenAPI Schema. The field name MUST begin with `x-`, for example, `x-internal-id`. The value can be `null`, a primitive, an array or an object. Can have any valid JSON format value.

The extensions may or may not be supported by the available tooling, but those may be extended as well to add requested support (if tools are internal or open-sourced).

### <a name="securityFiltering"></a>Security Filtering

Some objects in the OpenAPI Specification MAY be declared and remain empty, or completely be removed, even though they are inherently the core of the API documentation. 

The reasoning behind it is to allow an additional layer of access control over the documentation itself.
While not part of the specification itself, certain libraries MAY choose to allow access to parts of the documentation based on some form of authentication/authorization.

Two examples for this:

1. The [Paths Object](#pathsObject) MAY be empty. It may be counterintuitive, but this may tell the viewer that they got to the right place, but can't access any documentation. They'd still have access to the [Info Object](#infoObject) which may contain additional information regarding authentication.
2. The [Path Item Object](#pathItemObject) MAY be empty. In this case, the viewer will be aware that the path exists, but will not be able to see any of its operations or parameters. This is different than hiding the path itself from the [Paths Object](#pathsObject) so the user will not be aware of its existence. This allows the documentation provider a finer control over what the viewer can see.

## <a name="revisionHistory"></a>Appendix A: Revision History

Version | Date | Notes
---   | --- | ---
3.0.0-rc0 | 2017-02-28 | Implementer's Draft of the 3.0 specification
2.0   | 2015-12-31 | Donation of Swagger 2.0 to the Open API Initiative
2.0   | 2014-09-08 | Release of Swagger 2.0
1.2   | 2014-03-14 | Initial release of the formal document.
1.1   | 2012-08-22 | Release of Swagger 1.1
1.0   | 2011-08-10 | First release of the Swagger Specification
